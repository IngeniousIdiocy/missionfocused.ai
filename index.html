<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MissionFocused.ai - Mission Control</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  overflow: hidden;
  background: #000;
  color: #fff;
}
#canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
#instructions {
  position: fixed;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(84, 198, 255, 0.1);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 15px 30px;
  border-radius: 30px;
  backdrop-filter: blur(10px);
  font-size: 14px;
  text-align: center;
  z-index: 100;
  cursor: pointer;
  user-select: none;
  transition: all 0.3s ease;
}
#instructions:hover {
  background: rgba(84, 198, 255, 0.2);
  border: 1px solid rgba(84, 198, 255, 0.5);
  transform: translateX(-50%) scale(1.05);
}
#camera-toggle {
  position: fixed;
  bottom: 10px;
  left: calc(50% + 120px);
  transform: translateX(-50%);
  background: rgba(84, 198, 255, 0.1);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 15px;
  border-radius: 50%;
  backdrop-filter: blur(10px);
  font-size: 18px;
  text-align: center;
  z-index: 100;
  cursor: pointer;
  user-select: none;
  transition: all 0.3s ease;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}
#camera-toggle:hover {
  background: rgba(84, 198, 255, 0.2);
  border: 1px solid rgba(84, 198, 255, 0.5);
  transform: translateX(-50%) scale(1.05);
}
#camera-toggle.active {
  background: rgba(6, 255, 165, 0.2);
  border: 1px solid rgba(6, 255, 165, 0.5);
}
#settings-toggle {
  position: fixed;
  bottom: 10px;
  left: calc(50% - 120px);
  transform: translateX(-50%);
  background: rgba(84, 198, 255, 0.1);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 15px;
  border-radius: 50%;
  backdrop-filter: blur(10px);
  font-size: 18px;
  text-align: center;
  z-index: 100;
  cursor: pointer;
  user-select: none;
  transition: all 0.3s ease;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}
#settings-toggle:hover {
  background: rgba(84, 198, 255, 0.2);
  border: 1px solid rgba(84, 198, 255, 0.5);
  transform: translateX(-50%) scale(1.05);
}
#settings-toggle.active {
  background: rgba(255, 91, 195, 0.2);
  border: 1px solid rgba(255, 91, 195, 0.5);
}
#logo {
  position: fixed;
  top: 20px;
  left: 20px;
  font-size: 24px;
  font-weight: 600;
  color: #54c6ff;
  text-shadow: 0 0 20px rgba(84, 198, 255, 0.5);
  z-index: 100;
}
#controls {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 20px;
  border-radius: 10px;
  backdrop-filter: blur(10px);
  z-index: 100;
  color: #fff;
  font-family: monospace;
  font-size: 12px;
  display: none;
  transition: opacity 0.3s ease;
  min-width: 220px;
}
#controls label {
  display: block;
  margin-bottom: 5px;
  color: #54c6ff;
}
#controls input[type="range"] {
  width: 150px;
  margin-bottom: 15px;
  display: inline-block;
  margin-right: 10px;
}
#controls .value {
  color: #06ffa5;
  font-weight: bold;
  display: inline-block;
  vertical-align: middle;
}
.desktop-only {
  display: block;
}
/* Hide desktop-only controls on touch devices */
@media (hover: none) and (pointer: coarse) {
  .desktop-only {
    display: none !important;
  }
}
</style>
</head>
<body>
<div id="logo">MissionFocused.ai</div>
<div id="settings-toggle">‚öôÔ∏è</div>
<div id="instructions">panel</div>
<div id="camera-toggle">üì∑</div>
<div id="controls">
  <label>Panel Z-Depth (Landscape)</label>
  <input type="range" id="panelZDepthLandscape" min="0" max="7" step="0.5" value="6">
  <span class="value" id="panelZDepthLandscapeValue">6</span>
  
  <label>Panel Z-Depth (Portrait)</label>
  <input type="range" id="panelZDepthPortrait" min="0" max="7" step="0.5" value="4.8">
  <span class="value" id="panelZDepthPortraitValue">4.8</span>
  
  <label class="desktop-only">Movement Speed</label>
  <input type="range" id="moveSpeed" min="0.1" max="2" step="0.1" value="0.5" class="desktop-only">
  <span class="value desktop-only" id="moveSpeedValue">0.5</span>
  
  <label class="desktop-only">Mouse Sensitivity</label>
  <input type="range" id="mouseSensitivity" min="0.1" max="3" step="0.1" value="1" class="desktop-only">
  <span class="value desktop-only" id="mouseSensitivityValue">1</span>
  
  <label>Background Sphere Opacity</label>
  <input type="range" id="sphereOpacity" min="0" max="1" step="0.1" value="0.2">
  <span class="value" id="sphereOpacityValue">0.2</span>
  
  <label>Background Sphere Intensity</label>
  <input type="range" id="sphereIntensity" min="0" max="1" step="0.1" value="1">
  <span class="value" id="sphereIntensityValue">1</span>
  
  <label>Fog Opacity</label>
  <input type="range" id="fogOpacity" min="0" max="0.2" step="0.01" value="0.2">
  <span class="value" id="fogOpacityValue">0.2</span>
  
  <label>Fog Saturation</label>
  <input type="range" id="fogSaturation" min="0" max="1" step="0.1" value="1">
  <span class="value" id="fogSaturationValue">1</span>
  
  <label>Radar Plane Opacity</label>
  <input type="range" id="radarOpacity" min="0" max="1" step="0.1" value="1">
  <span class="value" id="radarOpacityValue">1</span>
  
  <label>Radar Background Alpha</label>
  <input type="range" id="radarBgAlpha" min="0" max="0.2" step="0.01" value="0.2">
  <span class="value" id="radarBgAlphaValue">0.2</span>
  
  <label>Radar Line Alpha</label>
  <input type="range" id="radarLineAlpha" min="0" max="1" step="0.1" value="1">
  <span class="value" id="radarLineAlphaValue">1</span>
  
  <label>Panel Matrix Opacity</label>
  <input type="range" id="panelMatrixOpacity" min="0" max="2" step="0.1" value="2">
  <span class="value" id="panelMatrixOpacityValue">2</span>
  
  <label>Panel Matrix Intensity</label>
  <input type="range" id="panelMatrixIntensity" min="0" max="2" step="0.1" value="2">
  <span class="value" id="panelMatrixIntensityValue">2</span>
  
  <label>Lights Per Glass Layer</label>
  <input type="range" id="lightsPerLayer" min="1" max="5" step="1" value="5">
  <span class="value" id="lightsPerLayerValue">5</span>
  
  <label>Spotlight Intensity</label>
  <input type="range" id="spotlightIntensity" min="5" max="50" step="5" value="5">
  <span class="value" id="spotlightIntensityValue">5</span>
  
  <label>Content Panel Background</label>
  <input type="range" id="panelBgOpacity" min="0" max="1" step="0.1" value="0">
  <span class="value" id="panelBgOpacityValue">0</span>
  
  <label>Content Panel Text</label>
  <input type="range" id="panelTextOpacity" min="0" max="1" step="0.1" value="0.9">
  <span class="value" id="panelTextOpacityValue">0.9</span>
</div>
<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Scene setup with darker fog for spotlight drama
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 3, 40); // Thicker, closer fog for more dramatic lighting

// Original camera position (panels will always animate to this position)
const ORIGINAL_CAMERA_POSITION = new THREE.Vector3(0, 3, 10);
const ORIGINAL_CAMERA_TARGET = new THREE.Vector3(0, 2, 0);

// Camera movement variables
let moveSpeedValue = 0.5;
let mouseSensitivityValue = 1;

// Movement state
const keys = {
  w: false,
  a: false,
  s: false,
  d: false
};
let mouseX = 0, mouseY = 0;
let isPointerLocked = false;
let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let touchStartX = 0;
let touchStartY = 0;
let isCameraFree = false;

// Camera boundaries
const CAMERA_BOUNDS = {
  x: { min: -20, max: 20 },
  y: { min: 1, max: 8 },
  z: { min: -15, max: 12 }
};

// Lighting control variables
let sphereOpacityValue = 0.2;
let sphereIntensityValue = 1;
let fogOpacityValue = 0.2;
let fogSaturationValue = 1;
let radarOpacityValue = 1;
let radarBgAlphaValue = 0.2;
let radarLineAlphaValue = 1;
let panelMatrixOpacityValue = 2;
let panelMatrixIntensityValue = 2;
let lightsPerLayerValue = 5;
let spotlightIntensityValue = 5;
let panelBgOpacityValue = 0;
let panelTextOpacityValue = 0.9;
let panelZDepthLandscapeValue = 6;
let panelZDepthPortraitValue = 4.8;

// Setup control event listeners
function setupControls() {
  // Camera controls
  const moveSpeed = document.getElementById('moveSpeed');
  const mouseSensitivity = document.getElementById('mouseSensitivity');
  
  moveSpeed.addEventListener('input', (e) => {
    moveSpeedValue = parseFloat(e.target.value);
    document.getElementById('moveSpeedValue').textContent = moveSpeedValue;
  });
  
  mouseSensitivity.addEventListener('input', (e) => {
    mouseSensitivityValue = parseFloat(e.target.value);
    document.getElementById('mouseSensitivityValue').textContent = mouseSensitivityValue;
  });
  
  // Lighting controls
  const sphereOpacity = document.getElementById('sphereOpacity');
  const sphereIntensity = document.getElementById('sphereIntensity');
  const fogOpacity = document.getElementById('fogOpacity');
  const fogSaturation = document.getElementById('fogSaturation');
  
  sphereOpacity.addEventListener('input', (e) => {
    sphereOpacityValue = parseFloat(e.target.value);
    document.getElementById('sphereOpacityValue').textContent = sphereOpacityValue;
  });
  
  sphereIntensity.addEventListener('input', (e) => {
    sphereIntensityValue = parseFloat(e.target.value);
    document.getElementById('sphereIntensityValue').textContent = sphereIntensityValue;
  });
  
  fogOpacity.addEventListener('input', (e) => {
    fogOpacityValue = parseFloat(e.target.value);
    document.getElementById('fogOpacityValue').textContent = fogOpacityValue;
  });
  
  fogSaturation.addEventListener('input', (e) => {
    fogSaturationValue = parseFloat(e.target.value);
    document.getElementById('fogSaturationValue').textContent = fogSaturationValue;
  });
  
  const radarOpacity = document.getElementById('radarOpacity');
  const radarBgAlpha = document.getElementById('radarBgAlpha');
  const radarLineAlpha = document.getElementById('radarLineAlpha');
  
  radarOpacity.addEventListener('input', (e) => {
    radarOpacityValue = parseFloat(e.target.value);
    document.getElementById('radarOpacityValue').textContent = radarOpacityValue;
  });
  
  radarBgAlpha.addEventListener('input', (e) => {
    radarBgAlphaValue = parseFloat(e.target.value);
    document.getElementById('radarBgAlphaValue').textContent = radarBgAlphaValue;
  });
  
  radarLineAlpha.addEventListener('input', (e) => {
    radarLineAlphaValue = parseFloat(e.target.value);
    document.getElementById('radarLineAlphaValue').textContent = radarLineAlphaValue;
  });
  
  const panelMatrixOpacity = document.getElementById('panelMatrixOpacity');
  const panelMatrixIntensity = document.getElementById('panelMatrixIntensity');
  
  panelMatrixOpacity.addEventListener('input', (e) => {
    panelMatrixOpacityValue = parseFloat(e.target.value);
    document.getElementById('panelMatrixOpacityValue').textContent = panelMatrixOpacityValue;
  });
  
  panelMatrixIntensity.addEventListener('input', (e) => {
    panelMatrixIntensityValue = parseFloat(e.target.value);
    document.getElementById('panelMatrixIntensityValue').textContent = panelMatrixIntensityValue;
  });
  
  const lightsPerLayer = document.getElementById('lightsPerLayer');
  const spotlightIntensity = document.getElementById('spotlightIntensity');
  
  lightsPerLayer.addEventListener('input', (e) => {
    lightsPerLayerValue = parseInt(e.target.value);
    document.getElementById('lightsPerLayerValue').textContent = lightsPerLayerValue;
    // Recreate lights with new count
    recreateLights();
  });
  
  spotlightIntensity.addEventListener('input', (e) => {
    spotlightIntensityValue = parseFloat(e.target.value);
    document.getElementById('spotlightIntensityValue').textContent = spotlightIntensityValue;
  });
  
  const panelBgOpacity = document.getElementById('panelBgOpacity');
  const panelTextOpacity = document.getElementById('panelTextOpacity');
  
  panelBgOpacity.addEventListener('input', (e) => {
    panelBgOpacityValue = parseFloat(e.target.value);
    document.getElementById('panelBgOpacityValue').textContent = panelBgOpacityValue;
  });
  
  panelTextOpacity.addEventListener('input', (e) => {
    panelTextOpacityValue = parseFloat(e.target.value);
    document.getElementById('panelTextOpacityValue').textContent = panelTextOpacityValue;
  });
  
  const panelZDepthLandscape = document.getElementById('panelZDepthLandscape');
  const panelZDepthPortrait = document.getElementById('panelZDepthPortrait');
  
  panelZDepthLandscape.addEventListener('input', (e) => {
    panelZDepthLandscapeValue = parseFloat(e.target.value);
    document.getElementById('panelZDepthLandscapeValue').textContent = panelZDepthLandscapeValue;
  });
  
  panelZDepthPortrait.addEventListener('input', (e) => {
    panelZDepthPortraitValue = parseFloat(e.target.value);
    document.getElementById('panelZDepthPortraitValue').textContent = panelZDepthPortraitValue;
  });
}

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// Initialize camera position
camera.position.copy(ORIGINAL_CAMERA_POSITION);
camera.lookAt(ORIGINAL_CAMERA_TARGET);

// Content for screens
const screenContent = [
  {
    title: "MISSION FOCUSED",
    content: "Automate to Amplify Your Mission\n\nMissionFocused.ai streamlines your nonprofit's back office so you can focus on impact.",
    color: 0x54c6ff
  },
  {
    title: "ABOUT US",
    content: "Born from a passion for nonprofit efficiency, MissionFocused.ai helps organizations slash overhead and channel more resources directly to mission.\n\nOur founders are veterans of the charity world who know the constraints of limited staff, outdated software, and rigid compliance.",
    color: 0xff5bc3
  },
  {
    title: "PLATFORM SYSTEMS",
    content: "‚Ä¢ No-Code Workflows\n‚Ä¢ Composable Data Hub\n‚Ä¢ AI Document Copilot\n‚Ä¢ Audit-Ready Ledger\n\nDrag-and-drop builders, unified APIs, OCR + LLMs, and immutable transaction logging.",
    color: 0x8c62ff
  },
  {
    title: "SERVICES FOR NONPROFITS",
    content: "‚Ä¢ Configure Finance AI Agents\n‚Ä¢ CRM migrations & donor segmentation\n‚Ä¢ Custom AI assistants for case management\n‚Ä¢ Grant compliance & reporting automation",
    color: 0x06ffa5
  },
  {
    title: "SECURITY PROTOCOLS",
    content: "NEVER LOSE INFORMATION\nCollect web snippets, docs, and emails from any device. Instant, secure sync.\n\nHARDENED SECURITY\nEnd-to-end encryption. Export anytime, integrate with Zapier, self-host on request.",
    color: 0x54c6ff
  },
  {
    title: "INTEL ON MISSION FOCUSED",
    content: "Q: Is MissionFocused.ai just for US nonprofits?\nA: No ‚Äî multi-currency and GDPR compliant.\n\nQ: Can we deploy on-prem?\nA: Yes, via Kubernetes operator.\n\nQ: Discounts?\nA: Early adopters receive lifetime 30% off.",
    color: 0xff5bc3
  },
  {
    title: "CONTACT US",
    content: "CONTACT MISSION CONTROL\n\nhello@missionfocused.ai\n\nWe'd love to learn about your mission and help you achieve maximum impact with minimal overhead.",
    color: 0x8c62ff
  }
];

// Minimal ambient lighting to make spotlights dramatically visible
const ambientLight = new THREE.AmbientLight(0x0a0a1a, 0.1);
scene.add(ambientLight);

// Dynamic lighting system for glassmorphism effects
const lights = [];
const baseColors = [0xff0080, 0x0080ff, 0x80ff00, 0xff8000]; // Bold, saturated colors

// Function to create lights based on current settings
function createLights() {
  // Clear existing lights
  lights.forEach(light => scene.remove(light));
  lights.length = 0;
  
  // Create lights for each glass layer
  for (let layer = 0; layer < 4; layer++) {
    for (let lightIndex = 0; lightIndex < lightsPerLayerValue; lightIndex++) {
      const light = new THREE.PointLight(
        baseColors[layer], 
        spotlightIntensityValue,
        80
      );
      
      // Position lights in small constrained boxes between glass panes
      const zDepth = -9 - (layer * 3) + (lightIndex * 0.5); // Slight Z offset per light in layer
      light.position.set(
        (Math.random() - 0.5) * 20, // x = ¬±10 (smaller box than glass)
        3 + Math.random() * 4,      // y = 3-7 (constrained height)
        zDepth + Math.random() * 1  // slight z variation within layer
      );
      
      // Store layer info for animation
      light.userData = {
        layer: layer,
        lightIndex: lightIndex,
        baseZ: zDepth
      };
      
      scene.add(light);
      lights.push(light);
    }
  }
}

// Function to recreate lights when settings change
function recreateLights() {
  createLights();
}

// Initial light creation
createLights();

// Radar system
const radarCanvas = document.createElement('canvas');
radarCanvas.width = 512;
radarCanvas.height = 512;
const radarCtx = radarCanvas.getContext('2d');

const radarGeometry = new THREE.PlaneGeometry(50, 25); // Full grid width, half height
const radarTexture = new THREE.CanvasTexture(radarCanvas);
const radarMaterial = new THREE.MeshBasicMaterial({
  map: radarTexture,
  transparent: true,
  opacity: 0.8, // Slightly more opaque to maintain readability while showing glass effects
  side: THREE.DoubleSide,
  alphaTest: 0.1 // Allow better alpha blending with background glass effects
});

const radarMesh = new THREE.Mesh(radarGeometry, radarMaterial);
radarMesh.position.set(0, -2, -25); // Animation center at floor level
radarMesh.rotation.x = 0; // Vertical on wall
scene.add(radarMesh);

// Bogey tracking data
const bogeys = [
  { x: 0.3, y: 0.2, speed: 0.02, direction: Math.PI / 4, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.02 },
  { x: -0.4, y: 0.1, speed: 0.015, direction: -Math.PI / 3, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.015 },
  { x: 0.1, y: -0.35, speed: 0.025, direction: Math.PI * 0.8, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.025 },
  { x: -0.2, y: -0.3, speed: 0.018, direction: Math.PI * 1.2, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.018 }
];

let radarRotation = 0;

// Shared panel matrix system
const panelMatrixCanvas = document.createElement('canvas');
panelMatrixCanvas.width = 1024;
panelMatrixCanvas.height = 1024;
const panelMatrixCtx = panelMatrixCanvas.getContext('2d');

// Panel matrix columns
const panelMatrixColumns = [];
const columnCount = 80; // More columns for larger canvas

// Initialize panel matrix
function initializePanelMatrix() {
  for (let i = 0; i < columnCount; i++) {
    panelMatrixColumns.push({
      x: (i * 12) + Math.random() * 4,
      y: Math.random() * -1000,
      speed: 0.5 + Math.random() * 1,
      chars: [],
      lastChar: 0
    });
  }
}

// Update shared panel matrix
function updatePanelMatrix() {
  // Clear canvas
  panelMatrixCtx.clearRect(0, 0, panelMatrixCanvas.width, panelMatrixCanvas.height);
  
  panelMatrixColumns.forEach(column => {
    // Move column down
    column.y += column.speed;
    
    // Add new character occasionally
    column.lastChar += 1;
    if (column.lastChar > 15 + Math.random() * 30) {
      column.chars.push({
        char: matrixChars[Math.floor(Math.random() * matrixChars.length)],
        y: column.y,
        alpha: 1
      });
      column.lastChar = 0;
    }
    
    // Update and draw characters
    for (let j = column.chars.length - 1; j >= 0; j--) {
      const char = column.chars[j];
      
      // Character fades as it gets older
      const distanceFromHead = column.y - char.y;
      char.alpha = Math.max(0, 1 - (distanceFromHead / 120));
      
      if (char.alpha > 0) {
        // Calculate alpha with intensity control
        const finalAlpha = char.alpha * panelMatrixIntensityValue;
        
        if (j === column.chars.length - 1) {
          // Head character - brighter
          panelMatrixCtx.fillStyle = `rgba(150, 255, 150, ${finalAlpha})`;
          panelMatrixCtx.font = 'bold 14px monospace';
        } else {
          // Trail characters
          panelMatrixCtx.fillStyle = `rgba(100, 200, 100, ${finalAlpha * 0.7})`;
          panelMatrixCtx.font = '12px monospace';
        }
        
        panelMatrixCtx.fillText(char.char, column.x, char.y);
      } else {
        // Remove faded characters
        column.chars.splice(j, 1);
      }
    }
    
    // Reset column when it goes off screen
    if (column.y > panelMatrixCanvas.height + 100) {
      column.y = Math.random() * -300;
      column.chars = [];
    }
  });
}

// Radar drawing function
function updateRadar() {
  const centerX = radarCanvas.width / 2;
  const centerY = radarCanvas.height / 2;
  const radius = centerX - 20;
  
  // Clear canvas (transparent background)
  radarCtx.clearRect(0, 0, radarCanvas.width, radarCanvas.height);
  
  // Set up clipping to show only top half
  radarCtx.save();
  radarCtx.beginPath();
  radarCtx.rect(0, 0, radarCanvas.width, radarCanvas.height / 2);
  radarCtx.clip();
  
  // Draw radar circles (glassmorphic) with controllable alpha
  radarCtx.strokeStyle = `rgba(84, 198, 255, ${radarLineAlphaValue})`;
  radarCtx.lineWidth = 1;
  for (let i = 1; i <= 4; i++) {
    radarCtx.beginPath();
    radarCtx.arc(centerX, centerY, (radius / 4) * i, 0, Math.PI * 2);
    radarCtx.stroke();
  }
  
  // Draw crosshairs
  radarCtx.beginPath();
  radarCtx.moveTo(centerX - radius, centerY);
  radarCtx.lineTo(centerX + radius, centerY);
  radarCtx.moveTo(centerX, centerY - radius);
  radarCtx.lineTo(centerX, centerY + radius);
  radarCtx.stroke();
  
  // Update bogey positions with random movement
  bogeys.forEach(bogey => {
    // Random direction changes
    bogey.lastDirectionChange += 1;
    if (bogey.lastDirectionChange > 30 + Math.random() * 120) { // Change direction every 30-150 frames
      bogey.direction += (Math.random() - 0.5) * Math.PI * 0.8; // Random turn up to ¬±72 degrees
      bogey.lastDirectionChange = 0;
    }
    
    // Random speed variations
    bogey.speed = bogey.baseSpeed * (0.5 + Math.random() * 1.5); // 50% to 200% of base speed
    
    // Add small random jitter to movement
    const jitterX = (Math.random() - 0.5) * 0.005;
    const jitterY = (Math.random() - 0.5) * 0.005;
    
    // Move bogey
    bogey.x += Math.cos(bogey.direction) * bogey.speed + jitterX;
    bogey.y += Math.sin(bogey.direction) * bogey.speed + jitterY;
    
    // Keep bogeys in bounds with more random bouncing
    const distance = Math.sqrt(bogey.x * bogey.x + bogey.y * bogey.y);
    if (distance > 0.9) {
      // Random bounce angle instead of simple reverse
      const bounceAngle = Math.atan2(bogey.y, bogey.x) + Math.PI + (Math.random() - 0.5) * Math.PI * 0.5;
      bogey.direction = bounceAngle;
      bogey.lastDirectionChange = 0; // Reset direction change timer
    }
    
    // Limit to radar range
    if (distance > 0.95) {
      bogey.x *= 0.9;
      bogey.y *= 0.9;
    }
  });
  
  // Draw sweep line (rotating)
  radarRotation += 0.06;
  const sweepX = centerX + Math.cos(radarRotation) * radius;
  const sweepY = centerY + Math.sin(radarRotation) * radius;
  
  // Sweep trail effect
  const gradient = radarCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
  gradient.addColorStop(0, 'rgba(0, 255, 100, 0.8)');
  gradient.addColorStop(0.3, 'rgba(0, 255, 100, 0.4)');
  gradient.addColorStop(1, 'rgba(0, 255, 100, 0)');
  
  radarCtx.save();
  radarCtx.translate(centerX, centerY);
  radarCtx.rotate(radarRotation);
  radarCtx.beginPath();
  radarCtx.moveTo(0, 0);
  radarCtx.arc(0, 0, radius, -Math.PI / 6, Math.PI / 6);
  radarCtx.closePath();
  radarCtx.fillStyle = gradient;
  radarCtx.fill();
  radarCtx.restore();
  
  // Draw sweep line
  radarCtx.strokeStyle = 'rgba(0, 255, 100, 1)';
  radarCtx.lineWidth = 2;
  radarCtx.beginPath();
  radarCtx.moveTo(centerX, centerY);
  radarCtx.lineTo(sweepX, sweepY);
  radarCtx.stroke();
  
  // Draw bogeys
  bogeys.forEach(bogey => {
    const bogeyX = centerX + bogey.x * radius;
    const bogeyY = centerY + bogey.y * radius;
    
    // Calculate if bogey should be highlighted (recently swept)
    const bogeyAngle = Math.atan2(bogey.y, bogey.x);
    let angleDiff = Math.abs(radarRotation - bogeyAngle);
    if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
    
    if (angleDiff < 0.2) {
      bogey.lastPing = time;
    }
    
    // Draw bogey with fade effect
    const timeSincePing = time - bogey.lastPing;
    const alpha = Math.max(0, 1 - timeSincePing * 0.3);
    
    if (alpha > 0) {
      radarCtx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
      radarCtx.beginPath();
      radarCtx.arc(bogeyX, bogeyY, 4, 0, Math.PI * 2);
      radarCtx.fill();
      
      // Draw target rings
      radarCtx.strokeStyle = `rgba(255, 100, 100, ${alpha * 0.5})`;
      radarCtx.lineWidth = 1;
      radarCtx.beginPath();
      radarCtx.arc(bogeyX, bogeyY, 8, 0, Math.PI * 2);
      radarCtx.stroke();
    }
  });
  
  // Restore canvas context (remove clipping)
  radarCtx.restore();
  
  radarTexture.needsUpdate = true;
}

// Floor grid
const gridHelper = new THREE.GridHelper(50, 50, 0x1a1a2e, 0x1a1a2e);
gridHelper.position.y = -2;
scene.add(gridHelper);

// 4 massive glass panes between content and radar for seamless glassmorphism
const glassPanels = [];
const glassColors = [0x800040, 0x004080, 0x408000, 0x804000]; // Match light colors but darker

for (let i = 0; i < 4; i++) {
  const glassPanel = new THREE.Mesh(
    new THREE.PlaneGeometry(150, 130), // MASSIVE size so edges are never visible from normal view
    new THREE.MeshPhysicalMaterial({
      color: glassColors[i],
      metalness: 0.3, // Higher metalness for more intense reflections
      roughness: 0.01, // Even smoother for maximum reflection
      transparent: true,
      opacity: 0.35, // Higher opacity to make light effects more visible
      transmission: 0.95, // Slightly reduced for more dramatic light interaction
      ior: 2.0 + i * 0.3, // Even more dramatic IOR differences for each pane
      side: THREE.DoubleSide
    })
  );
  
  // Position each pane between content panels (z=-5) and radar (z=-25)
  glassPanel.position.set(
    0,                    // Centered
    15,                   // Position to cover the viewing area (bottom at y=-25, top at y=55)
    -8 - (i * 3)         // z = -8, -11, -14, -17 (between content at -5 and radar at -25)
  );
  
  scene.add(glassPanel);
  glassPanels.push(glassPanel);
}

// Darker background sphere to make spotlights more dramatic
const backgroundSphere = new THREE.Mesh(
  new THREE.SphereGeometry(120, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0x1a0820, // Much darker purple
    transparent: true,
    opacity: sphereOpacityValue * 0.5, // Half opacity for darker background
    side: THREE.BackSide
  })
);
backgroundSphere.position.set(0, 0, -55); // Further back to encompass glass layers
scene.add(backgroundSphere);

// Create screens
const screens = [];
const screenGroups = [];
const panelCanvases = []; // Store panel canvases for animation updates

function createScreen(content, index) {
  const group = new THREE.Group();
  
  const geometry = new THREE.PlaneGeometry(4, 3);
  const material = new THREE.MeshPhongMaterial({
    color: content.color,
    emissive: content.color,
    emissiveIntensity: 0.2,
    transparent: true,
    opacity: panelBgOpacityValue,
    side: THREE.DoubleSide
  });
  
  const screen = new THREE.Mesh(geometry, material);
  
  // Create text texture
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 384;
  const ctx = canvas.getContext('2d');
  
  // Store canvas info for animation updates
  const panelInfo = {
    canvas: canvas,
    ctx: ctx,
    texture: null,
    content: content,
    index: index
  };
  
  // Initial draw - will be updated in animation loop
  // Draw background
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  const texture = new THREE.CanvasTexture(canvas);
  panelInfo.texture = texture;
  
  const textMaterial = new THREE.MeshBasicMaterial({ 
    map: texture, 
    transparent: true,
    opacity: panelTextOpacityValue
  });
  const textMesh = new THREE.Mesh(geometry, textMaterial);
  textMesh.position.z = 0.01;
  
  // Store panel info for updates
  panelCanvases.push(panelInfo);
  
  group.add(screen);
  group.add(textMesh);
  
  // Position screens in two rows
  const row = index < 4 ? 0 : 1;
  const col = index < 4 ? index : index - 4;
  const colsInRow = index < 4 ? 4 : 3;
  
  const xSpacing = 9;
  const ySpacing = 4;
  const xOffset = -(colsInRow - 1) * xSpacing / 2;
  
  group.position.x = xOffset + col * xSpacing;
  group.position.y = row === 0 ? 5 : 1;
  group.position.z = -5;
  
  // Angle panels slightly toward viewer
  group.rotation.y = -group.position.x * 0.03;
  
  // Store original transform and material references
  group.userData = {
    originalPosition: group.position.clone(),
    originalRotation: group.rotation.clone(),
    originalScale: group.scale.clone(),
    targetPosition: new THREE.Vector3(ORIGINAL_CAMERA_POSITION.x, 2.5, 6), // Panels fly to original camera position
    targetRotation: new THREE.Euler(0, 0, 0),
    targetScale: new THREE.Vector3(1.2, 1.2, 1.2),
    screen: screen,
    screenMaterial: material,
    textMaterial: textMaterial,
    index: index,
    animating: false,
    focused: false
  };
  
  scene.add(group);
  screens.push(screen);
  screenGroups.push(group);
  
  return group;
}

// Create all screens
screenContent.forEach((content, i) => createScreen(content, i));

// Function to update all panel backgrounds
function updatePanelBackgrounds() {
  panelCanvases.forEach(panelInfo => {
    const { canvas, ctx, content, index } = panelInfo;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw matrix background (sample from shared canvas)
    if (panelMatrixOpacityValue > 0) {
      const sampleX = (index * 120) % (panelMatrixCanvas.width - canvas.width);
      const sampleY = Math.floor(index / 4) * 250 % (panelMatrixCanvas.height - canvas.height);
      
      ctx.globalAlpha = panelMatrixOpacityValue;
      ctx.drawImage(panelMatrixCanvas, sampleX, sampleY, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
      ctx.globalAlpha = 1;
    }
    
    // Draw background
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    ctx.strokeStyle = `rgba(${content.color >> 16 & 255}, ${content.color >> 8 & 255}, ${content.color & 255}, 0.8)`;
    ctx.lineWidth = 3;
    ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
    
    // Draw title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px monospace';
    ctx.fillText(content.title, 20, 40);
    
    // Draw content with word wrap
    ctx.font = '16px monospace';
    const lines = content.content.split('\n');
    const maxWidth = canvas.width - 40;
    let currentY = 80;
    
    lines.forEach((line) => {
      if (line.trim() === '') {
        currentY += 25;
        return;
      }
      
      const words = line.split(' ');
      let currentLine = '';
      
      for (let n = 0; n < words.length; n++) {
        const testLine = currentLine + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        
        if (testWidth > maxWidth && n > 0) {
          ctx.fillText(currentLine, 20, currentY);
          currentLine = words[n] + ' ';
          currentY += 25;
        } else {
          currentLine = testLine;
        }
      }
      ctx.fillText(currentLine, 20, currentY);
      currentY += 25;
    });
    
    panelInfo.texture.needsUpdate = true;
  });
}

// Control stations
const controlStations = [];

function createControlStation(x, z) {
  const group = new THREE.Group();
  
  // Base
  const baseGeometry = new THREE.BoxGeometry(2, 0.5, 1);
  const baseMaterial = new THREE.MeshPhongMaterial({ 
    color: 0x1a1a2e,
    emissive: 0x54c6ff,
    emissiveIntensity: 0.1
  });
  const base = new THREE.Mesh(baseGeometry, baseMaterial);
  group.add(base);
  
  // Screen
  const screenGeometry = new THREE.PlaneGeometry(1.8, 0.8);
  const screenMaterial = new THREE.MeshPhongMaterial({ 
    color: 0x54c6ff,
    emissive: 0x54c6ff,
    emissiveIntensity: 0.5
  });
  const screen = new THREE.Mesh(screenGeometry, screenMaterial);
  screen.position.y = 0.5;
  screen.rotation.x = -Math.PI / 6;
  group.add(screen);
  
  // Animated display canvas
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  
  const texture = new THREE.CanvasTexture(canvas);
  const displayMaterial = new THREE.MeshBasicMaterial({ map: texture });
  const display = new THREE.Mesh(screenGeometry, displayMaterial);
  display.position.copy(screen.position);
  display.position.z += 0.01;
  display.rotation.copy(screen.rotation);
  group.add(display);
  
  group.position.set(x, 0, z);
  scene.add(group);
  
  controlStations.push({ group, canvas, ctx, texture });
}

// Create control stations
createControlStation(-3, 6);
createControlStation(0, 6);
createControlStation(3, 6);

// Particles
const particlesGeometry = new THREE.BufferGeometry();
const particlesCount = 1000;
const posArray = new Float32Array(particlesCount * 3);

for (let i = 0; i < particlesCount * 3; i++) {
  posArray[i] = (Math.random() - 0.5) * 50;
}

particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const particlesMaterial = new THREE.PointsMaterial({
  size: 0.02,
  color: 0x54c6ff,
  transparent: true,
  opacity: 0.6
});
const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

// Panel animation
let currentFocus = -1;
let globalAnimating = false;

function animatePanel(group, toFront) {
  if (group.userData.animating) return;
  group.userData.animating = true;
  globalAnimating = true;
  
  const startPos = group.position.clone();
  const startRot = group.rotation.clone();
  const startScale = group.scale.clone();
  
  // Dynamic z-depth based on aspect ratio
  let dynamicTargetPos;
  if (toFront) {
    const aspectRatio = window.innerWidth / window.innerHeight;
    const isLandscape = aspectRatio > 1;
    const zDepth = isLandscape ? panelZDepthLandscapeValue : panelZDepthPortraitValue;
    dynamicTargetPos = new THREE.Vector3(ORIGINAL_CAMERA_POSITION.x, 2.5, zDepth);
  } else {
    dynamicTargetPos = group.userData.originalPosition;
  }
  
  const targetPos = dynamicTargetPos;
  const targetRot = toFront ? group.userData.targetRotation : group.userData.originalRotation;
  const targetScale = toFront ? group.userData.targetScale : group.userData.originalScale;
  
  // Store camera target for smooth tracking
  const startCameraTarget = ORIGINAL_CAMERA_TARGET.clone();
  
  let progress = 0;
  const animate = () => {
    progress += 0.025;
    if (progress >= 1) {
      group.userData.animating = false;
      group.userData.focused = toFront;
      globalAnimating = false;
      // Restore camera to original target
      camera.lookAt(ORIGINAL_CAMERA_TARGET);
      return;
    }
    
    const eased = 1 - Math.pow(1 - progress, 3);
    
    group.position.lerpVectors(startPos, targetPos, eased);
    group.scale.lerpVectors(startScale, targetScale, eased);
    
    // Slerp rotation for smooth animation
    group.rotation.x = startRot.x + (targetRot.x - startRot.x) * eased;
    group.rotation.y = startRot.y + (targetRot.y - startRot.y) * eased;
    group.rotation.z = startRot.z + (targetRot.z - startRot.z) * eased;
    
    // Add floating effect when focused
    if (toFront) {
      group.position.y = targetPos.y + Math.sin(progress * Math.PI) * 0.3;
    }
    
    // Camera tracks the center of the panel as it moves (only on fly in)
    if (toFront) {
      const currentCameraTarget = new THREE.Vector3();
      currentCameraTarget.lerpVectors(startCameraTarget, group.position, eased);
      camera.lookAt(currentCameraTarget);
    }
    
    requestAnimationFrame(animate);
  };
  animate();
}

function focusScreen(index) {
  // Ignore input while any animation is in progress
  if (globalAnimating) return;
  
  const group = screenGroups[index];
  
  if (currentFocus === index && group.userData.focused) {
    // Return to original position
    animatePanel(group, false);
    currentFocus = -1;
  } else {
    // Return previous panel if any
    if (currentFocus !== -1 && currentFocus !== index) {
      animatePanel(screenGroups[currentFocus], false);
    }
    // Bring new panel forward
    animatePanel(group, true);
    currentFocus = index;
  }
}

// Camera movement system
function updateCameraMovement() {
  // Only allow movement when camera is free
  if (!isCameraFree) return;
  
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();
  
  // Get camera direction for forward/back movement
  camera.getWorldDirection(direction);
  
  // Get right vector for strafe movement
  const right = new THREE.Vector3();
  right.crossVectors(camera.up, direction).normalize();
  
  // Apply movement based on pressed keys
  if (keys.w) velocity.add(direction.clone().multiplyScalar(moveSpeedValue));
  if (keys.s) velocity.add(direction.clone().multiplyScalar(-moveSpeedValue));
  if (keys.a) velocity.add(right.clone().multiplyScalar(moveSpeedValue));
  if (keys.d) velocity.add(right.clone().multiplyScalar(-moveSpeedValue));
  
  // Apply movement with boundary checking and bounce
  const newPosition = camera.position.clone().add(velocity);
  
  // Check collision with focused panel
  if (currentFocus !== -1) {
    const focusedPanel = screenGroups[currentFocus];
    if (focusedPanel.userData.focused) {
      const panelPos = focusedPanel.position;
      const distance = newPosition.distanceTo(panelPos);
      
      // If too close to focused panel, bounce back
      if (distance < 3) {
        const direction = newPosition.clone().sub(panelPos).normalize();
        newPosition.copy(panelPos.clone().add(direction.multiplyScalar(3)));
        velocity.multiplyScalar(-0.3); // Bounce effect
      }
    }
  }
  
  // Check X bounds with bounce
  if (newPosition.x < CAMERA_BOUNDS.x.min) {
    newPosition.x = CAMERA_BOUNDS.x.min;
    velocity.x = Math.abs(velocity.x) * 0.3; // Bounce back
  } else if (newPosition.x > CAMERA_BOUNDS.x.max) {
    newPosition.x = CAMERA_BOUNDS.x.max;
    velocity.x = -Math.abs(velocity.x) * 0.3; // Bounce back
  }
  
  // Check Y bounds with bounce
  if (newPosition.y < CAMERA_BOUNDS.y.min) {
    newPosition.y = CAMERA_BOUNDS.y.min;
    velocity.y = Math.abs(velocity.y) * 0.3; // Bounce back
  } else if (newPosition.y > CAMERA_BOUNDS.y.max) {
    newPosition.y = CAMERA_BOUNDS.y.max;
    velocity.y = -Math.abs(velocity.y) * 0.3; // Bounce back
  }
  
  // Check Z bounds with bounce
  if (newPosition.z < CAMERA_BOUNDS.z.min) {
    newPosition.z = CAMERA_BOUNDS.z.min;
    velocity.z = Math.abs(velocity.z) * 0.3; // Bounce back
  } else if (newPosition.z > CAMERA_BOUNDS.z.max) {
    newPosition.z = CAMERA_BOUNDS.z.max;
    velocity.z = -Math.abs(velocity.z) * 0.3; // Bounce back
  }
  
  camera.position.copy(newPosition);
}

// Mouse movement for camera look
function onMouseMove(event) {
  if (!isPointerLocked || !isCameraFree || isTouchDevice) return;
  
  const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
  const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
  
  mouseX += movementX * mouseSensitivityValue * 0.002;
  mouseY += movementY * mouseSensitivityValue * 0.002;
  
  // Limit vertical rotation
  mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
  
  // Apply rotation
  camera.rotation.order = 'YXZ';
  camera.rotation.y = -mouseX;
  camera.rotation.x = -mouseY;
}

// Touch event handlers for mobile camera control
function onTouchStart(event) {
  if (!isCameraFree || !isTouchDevice) return;
  event.preventDefault();
  
  const touch = event.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}

function onTouchMove(event) {
  if (!isCameraFree || !isTouchDevice) return;
  event.preventDefault();
  
  const touch = event.touches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  
  // Apply touch sensitivity (inverted for mobile)
  mouseX -= deltaX * mouseSensitivityValue * 0.003;
  mouseY -= deltaY * mouseSensitivityValue * 0.003;
  
  // Limit vertical rotation
  mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
  
  // Apply rotation
  camera.rotation.order = 'YXZ';
  camera.rotation.y = -mouseX;
  camera.rotation.x = -mouseY;
  
  // Update touch start position for continuous rotation
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}

function onTouchEnd(event) {
  if (!isCameraFree || !isTouchDevice) return;
  event.preventDefault();
}

// Pointer lock handlers
function onPointerLockChange() {
  isPointerLocked = document.pointerLockElement === renderer.domElement;
}

function onPointerLockError() {
  console.log('Pointer lock error');
}

// Initialize pointer lock (without auto-start)
function initPointerLock() {
  document.addEventListener('pointerlockchange', onPointerLockChange);
  document.addEventListener('pointerlockerror', onPointerLockError);
  document.addEventListener('mousemove', onMouseMove);
  
  // Add touch event listeners for mobile support
  renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
  renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
  renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
}

// Camera toggle functionality
function toggleCamera() {
  const cameraButton = document.getElementById('camera-toggle');
  
  if (isCameraFree) {
    // Lock camera and return to original position
    isCameraFree = false;
    cameraButton.classList.remove('active');
    
    // Exit pointer lock (desktop only)
    if (!isTouchDevice && document.exitPointerLock) {
      document.exitPointerLock();
    }
    
    // Smoothly return camera to original position
    returnCameraToOriginal();
  } else {
    // Free camera
    isCameraFree = true;
    cameraButton.classList.add('active');
    
    // Request pointer lock (desktop only)
    if (!isTouchDevice) {
      renderer.domElement.requestPointerLock();
    }
  }
}

// Smooth camera return to original position
function returnCameraToOriginal() {
  const startPos = camera.position.clone();
  const startRotX = camera.rotation.x;
  const startRotY = camera.rotation.y;
  
  let progress = 0;
  const animate = () => {
    progress += 0.03;
    if (progress >= 1) {
      camera.position.copy(ORIGINAL_CAMERA_POSITION);
      camera.lookAt(ORIGINAL_CAMERA_TARGET);
      mouseX = 0;
      mouseY = 0;
      return;
    }
    
    const eased = 1 - Math.pow(1 - progress, 3);
    
    // Smoothly interpolate position
    camera.position.lerpVectors(startPos, ORIGINAL_CAMERA_POSITION, eased);
    
    // Smoothly interpolate rotation back to looking at target
    const targetRotation = new THREE.Euler();
    const tempCamera = new THREE.PerspectiveCamera();
    tempCamera.position.copy(camera.position);
    tempCamera.lookAt(ORIGINAL_CAMERA_TARGET);
    targetRotation.copy(tempCamera.rotation);
    
    camera.rotation.x = startRotX + (targetRotation.x - startRotX) * eased;
    camera.rotation.y = startRotY + (targetRotation.y - startRotY) * eased;
    
    requestAnimationFrame(animate);
  };
  animate();
}

// Panel cycling state
let panelCycleState = 0; // 0-6 for panels 1-7, 7 for home state

// Panel cycling button
document.getElementById('instructions').addEventListener('click', () => {
  // Ignore input while any animation is in progress
  if (globalAnimating) return;
  
  if (panelCycleState >= 0 && panelCycleState <= 6) {
    // Focus on panel (1-7)
    focusScreen(panelCycleState);
  } else {
    // Home state - return all panels
    if (currentFocus !== -1) {
      animatePanel(screenGroups[currentFocus], false);
      currentFocus = -1;
    }
  }
  
  // Increment cycle state with wrap-around
  panelCycleState = (panelCycleState + 1) % 8; // 0-7, then back to 0
});

// Camera toggle button
document.getElementById('camera-toggle').addEventListener('click', () => {
  toggleCamera();
});

// Settings toggle button
document.getElementById('settings-toggle').addEventListener('click', () => {
  const controls = document.getElementById('controls');
  const settingsButton = document.getElementById('settings-toggle');
  
  if (controls.style.display === 'none' || controls.style.display === '') {
    controls.style.display = 'block';
    settingsButton.classList.add('active');
  } else {
    controls.style.display = 'none';
    settingsButton.classList.remove('active');
  }
});

// WASD movement controls
window.addEventListener('keydown', (e) => {
  const key = e.key.toLowerCase();
  
  // WASD movement
  if (key === 'w') keys.w = true;
  if (key === 'a') keys.a = true;
  if (key === 's') keys.s = true;
  if (key === 'd') keys.d = true;
  
  // Panel controls
  const numKey = parseInt(e.key);
  if (numKey >= 1 && numKey <= 7) {
    // Ignore input while any animation is in progress
    if (globalAnimating) return;
    focusScreen(numKey - 1);
    // Sync button state with keyboard
    panelCycleState = numKey; // Next click will advance from current panel
  } else if (numKey === 0) {
    // Ignore input while any animation is in progress
    if (globalAnimating) return;
    if (currentFocus !== -1) {
      animatePanel(screenGroups[currentFocus], false);
      currentFocus = -1;
    }
    // Sync button state
    panelCycleState = 0; // Next click will go to panel 1
  } else if (key === 'c') {
    // Toggle controls visibility
    const controls = document.getElementById('controls');
    if (controls.style.display === 'none' || controls.style.display === '') {
      controls.style.display = 'block';
    } else {
      controls.style.display = 'none';
    }
  } else if (key === 'escape') {
    // Lock camera if it's currently free
    if (isCameraFree) {
      toggleCamera();
    }
  }
});

window.addEventListener('keyup', (e) => {
  const key = e.key.toLowerCase();
  
  // WASD movement
  if (key === 'w') keys.w = false;
  if (key === 'a') keys.a = false;
  if (key === 's') keys.s = false;
  if (key === 'd') keys.d = false;
});

// Animation loop
let time = 0;

// Matrix effect data for each station
const matrixColumns = [];
const matrixChars = '„Ç¢„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É©„ÉØ„Ç¨„Ç∂„ÉÄ„Éê„Éë„Ç≠„Ç∑„ÉÅ„Éã„Éí„Éü„É™„ÇÆ„Ç∏„ÉÇ„Éì„Éî„ÇØ„Çπ„ÉÑ„Éå„Éï„É†„É´„Ç∞„Ç∫„ÉÖ„Éñ„Éó„Ç±„Çª„ÉÜ„Éç„Éò„É°„É¨„Ç≤„Çº„Éá„Éô„Éö„Ç≥„ÇΩ„Éà„Éé„Éõ„É¢„É≠„Ç¥„Çæ„Éâ„Éú„Éù„ÅÇ„Åã„Åï„Åü„Å™„ÅØ„Åæ„ÇÑ„Çâ„Çè„Åå„Åñ„Å†„Å∞„Å±„Åç„Åó„Å°„Å´„Å≤„Åø„Çä„Åé„Åò„Å¢„Å≥„Å¥„Åè„Åô„Å§„Å¨„Åµ„ÇÄ„Çã„Åê„Åö„Å•„Å∂„Å∑„Åë„Åõ„Å¶„Å≠„Å∏„ÇÅ„Çå„Åí„Åú„Åß„Åπ„Å∫„Åì„Åù„Å®„ÅÆ„Åª„ÇÇ„Çç„Åî„Åû„Å©„Åº„ÅΩ‰∏≠ÂõΩÊó•Êú¨Ë™ûÊñáÂ≠ó‰π¶ÂÜôÊ±âÂ≠óÌïúÍµ≠Ïñ¥Í∏ÄÏûêÏ°∞ÏÑ†ÎßêÎ¨∏Ïûê';
const stationColors = ['#ff0040', '#00ff40', '#0040ff']; // Red, Green, Blue

// Initialize matrix columns for each station
function initializeMatrix() {
  for (let stationIndex = 0; stationIndex < 3; stationIndex++) {
    const columns = [];
    const columnCount = 20; // Number of falling columns
    
    for (let i = 0; i < columnCount; i++) {
      columns.push({
        x: (i * 12) + Math.random() * 4, // Column position with slight randomness
        y: Math.random() * -500, // Start above screen
        speed: 1 + Math.random() * 1.5, // Fall speed (half of original)
        chars: [], // Characters in this column
        lastChar: 0 // Time since last character
      });
    }
    matrixColumns.push(columns);
  }
}

function updateControlStations() {
  controlStations.forEach((station, i) => {
    const { ctx, canvas, texture } = station;
    
    // Darken background for trail effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Matrix falling code effect
    const columns = matrixColumns[i];
    const color = stationColors[i];
    
    columns.forEach(column => {
      // Move column down
      column.y += column.speed;
      
      // Add new character occasionally
      column.lastChar += 1;
      if (column.lastChar > 8 + Math.random() * 8) {
        column.chars.push({
          char: matrixChars[Math.floor(Math.random() * matrixChars.length)],
          y: column.y,
          alpha: 1
        });
        column.lastChar = 0;
      }
      
      // Update and draw characters
      for (let j = column.chars.length - 1; j >= 0; j--) {
        const char = column.chars[j];
        
        // Character fades as it gets older
        const distanceFromHead = column.y - char.y;
        char.alpha = Math.max(0, 1 - (distanceFromHead / 100));
        
        if (char.alpha > 0) {
          // Bright head character
          if (j === column.chars.length - 1) {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px monospace';
          } else {
            // Trailing characters in station color
            ctx.fillStyle = color.replace(')', `, ${char.alpha})`).replace('#', 'rgba(').replace(/(.{2})(.{2})(.{2})/, '$1, $2, $3');
            if (!ctx.fillStyle.includes('rgba')) {
              // Fallback for hex colors
              const r = parseInt(color.slice(1, 3), 16);
              const g = parseInt(color.slice(3, 5), 16);
              const b = parseInt(color.slice(5, 7), 16);
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${char.alpha})`;
            }
            ctx.font = '12px monospace';
          }
          
          ctx.fillText(char.char, column.x, char.y);
        } else {
          // Remove faded characters
          column.chars.splice(j, 1);
        }
      }
      
      // Reset column when it goes off screen
      if (column.y > canvas.height + 50) {
        column.y = Math.random() * -200;
        column.chars = [];
      }
    });
    
    texture.needsUpdate = true;
  });
}

function animate() {
  requestAnimationFrame(animate);
  time += 0.01;
  
  // Update camera movement
  updateCameraMovement();
  
  // Animate lights - each moves randomly in its assigned constrained box
  lights.forEach((light, i) => {
    const layer = light.userData.layer;
    const lightIndex = light.userData.lightIndex;
    const baseZ = light.userData.baseZ;
    
    // Smooth random movement within small constrained box
    light.position.x = Math.sin(time * 0.7 + i * 2) * 10;                    // x = ¬±10 (smaller than glass)
    light.position.y = 5 + Math.sin(time * 0.9 + i * 1.3) * 2;              // y = 3-7 (constrained height)
    light.position.z = baseZ + Math.sin(time * 0.5 + i * 1.7) * 1;          // z varies ¬±1 in layer
    
    // INTENSE color cycling for dramatic glass effects
    const hue = (time * 100 + layer * 90 + lightIndex * 30) % 360; // Faster, bolder color changes
    light.color.setHSL(hue / 360, 1.0, 0.8); // Maximum saturation and high brightness
    
    // Dynamic intensity based on user controls
    light.intensity = spotlightIntensityValue + Math.sin(time * 6 + i * 3) * (spotlightIntensityValue * 0.8);
  });
  
  // Update radar system
  updateRadar();
  
  // Update radar plane opacity
  radarMaterial.opacity = radarOpacityValue;
  
  // Update panel matrix system
  updatePanelMatrix();
  updatePanelBackgrounds();
  
  // Static glass panels - DRAMATIC material property changes for MAXIMUM intensity
  glassPanels.forEach((panel, i) => {
    // DRAMATIC opacity pulsing to enhance light interaction
    panel.material.opacity = 0.35 + Math.sin(time * 3 + i * 1.5) * 0.25; // 0.1 to 0.6 range
    
    // EXTREME IOR shifts for dramatic light refraction
    panel.material.ior = (2.0 + i * 0.3) + Math.sin(time * 2 + i) * 0.8; // 1.2 to 3.5 range
  });
  
  // Background color effects handled by glass panels and sphere
  
  // Animate background glow sphere color and opacity
  const bgHue = (time * 15) % 120; // Slower cycle, 120 degree range
  const bgColor = new THREE.Color().setHSL((bgHue + 240) / 360, 0.8, sphereIntensityValue); // Purple to blue
  backgroundSphere.material.color = bgColor;
  backgroundSphere.material.opacity = sphereOpacityValue;
  
  // Animate fog color
  const fogHue = (time * 10) % 60; // Even slower, smaller range
  const fogColor = new THREE.Color().setHSL((fogHue + 260) / 360, fogSaturationValue, fogOpacityValue); // Dark purple to dark blue
  scene.fog.color = fogColor;
  
  // Animate particles
  particlesMesh.rotation.y += 0.0005;
  
  // Pulse screens
  screens.forEach((screen, i) => {
    screen.material.emissiveIntensity = 0.2 + Math.sin(time * 2 + i) * 0.1;
  });
  
  // Float unfocused panels slightly and update opacities
  screenGroups.forEach((group, i) => {
    if (!group.userData.focused && !group.userData.animating) {
      group.position.y = group.userData.originalPosition.y + Math.sin(time + i) * 0.1;
    }
    
    // Update panel opacities from controls
    if (group.userData.screenMaterial) {
      group.userData.screenMaterial.opacity = panelBgOpacityValue;
    }
    if (group.userData.textMaterial) {
      group.userData.textMaterial.opacity = panelTextOpacityValue;
    }
  });
  
  // Update control stations
  updateControlStations();
  
  renderer.render(scene, camera);
}

// Initialize controls
setupControls();

// Initialize pointer lock event listeners
initPointerLock();

// Initialize matrix effect
initializeMatrix();

// Initialize panel matrix
initializePanelMatrix();

animate();

// Handle resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
