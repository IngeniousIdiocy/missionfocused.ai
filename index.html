<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MissionFocused.ai - Mission Control</title>
<script>
// Browser/Platform Detection (immediate execution)
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
const needsFallback = isSafari || isIOS;

// Store detection results globally
window.browserInfo = { isSafari, isIOS, needsFallback };
console.log('Browser detection:', window.browserInfo);
</script>

<script type="module">
// Load appropriate library based on browser
if (window.browserInfo.needsFallback) {
  // Load transformers.js for Safari/iOS compatibility - using minified version for speed
  const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.0/dist/transformers.min.js');
  window.transformers = { pipeline, env };
  env.allowRemoteModels = true;
  env.allowLocalModels = false;
  console.log('ü¶Ñ Safari/iOS detected - Loading transformers.js fallback');
} else {
  // Load MLC WebLLM for high performance on Chrome/Edge
  const webllm = await import("https://esm.run/@mlc-ai/web-llm");
  window.webllm = webllm;
  console.log('üöÄ Desktop browser detected - Loading MLC WebLLM');
}
</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  overflow: hidden;
  background: #000;
  color: #fff;
}
#canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
#instructions {
  position: fixed;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(84, 198, 255, 0.1);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 15px 30px;
  border-radius: 30px;
  backdrop-filter: blur(10px);
  font-size: 14px;
  text-align: center;
  z-index: 100;
  cursor: pointer;
  user-select: none;
  transition: all 0.3s ease;
}
#instructions:hover {
  background: rgba(84, 198, 255, 0.2);
  border: 1px solid rgba(84, 198, 255, 0.5);
  transform: translateX(-50%) scale(1.05);
}
#camera-toggle {
  position: fixed;
  bottom: 10px;
  left: calc(50% + 120px);
  transform: translateX(-50%);
  background: rgba(84, 198, 255, 0.1);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 15px;
  border-radius: 50%;
  backdrop-filter: blur(10px);
  font-size: 18px;
  text-align: center;
  z-index: 100;
  cursor: pointer;
  user-select: none;
  transition: all 0.3s ease;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}
#camera-toggle:hover {
  background: rgba(84, 198, 255, 0.2);
  border: 1px solid rgba(84, 198, 255, 0.5);
  transform: translateX(-50%) scale(1.05);
}
#camera-toggle.active {
  background: rgba(6, 255, 165, 0.2);
  border: 1px solid rgba(6, 255, 165, 0.5);
}
#fire-button {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 0, 0, 0.2);
  border: 1px solid rgba(255, 0, 0, 0.5);
  padding: 15px;
  border-radius: 50%;
  backdrop-filter: blur(10px);
  font-size: 18px;
  text-align: center;
  z-index: 100;
  cursor: pointer;
  user-select: none;
  transition: all 0.3s ease;
  width: 50px;
  height: 50px;
  display: none;
  align-items: center;
  justify-content: center;
}
#fire-button:hover {
  background: rgba(255, 0, 0, 0.3);
  border: 1px solid rgba(255, 0, 0, 0.7);
  transform: translateX(-50%) scale(1.05);
}
#fire-button.active {
  background: rgba(255, 0, 0, 0.4);
  border: 1px solid rgba(255, 0, 0, 0.8);
}
#settings-toggle {
  position: fixed;
  bottom: 10px;
  left: calc(50% - 120px);
  transform: translateX(-50%);
  background: rgba(84, 198, 255, 0.1);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 15px;
  border-radius: 50%;
  backdrop-filter: blur(10px);
  font-size: 18px;
  text-align: center;
  z-index: 100;
  cursor: pointer;
  user-select: none;
  transition: all 0.3s ease;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}
#settings-toggle:hover {
  background: rgba(84, 198, 255, 0.2);
  border: 1px solid rgba(84, 198, 255, 0.5);
  transform: translateX(-50%) scale(1.05);
}
#settings-toggle.active {
  background: rgba(255, 91, 195, 0.2);
  border: 1px solid rgba(255, 91, 195, 0.5);
}
#logo {
  position: fixed;
  top: 20px;
  left: 20px;
  font-size: 24px;
  font-weight: 600;
  color: #54c6ff;
  text-shadow: 0 0 20px rgba(84, 198, 255, 0.5);
  z-index: 100;
}
#controls {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(84, 198, 255, 0.3);
  padding: 20px;
  border-radius: 10px;
  backdrop-filter: blur(10px);
  z-index: 100;
  color: #fff;
  font-family: monospace;
  font-size: 12px;
  display: none;
  transition: opacity 0.3s ease;
  min-width: 200px;
}
#controls label {
  display: block;
  margin-bottom: 5px;
  color: #54c6ff;
}
#controls input[type="range"] {
  width: 150px;
  margin-bottom: 15px;
  display: inline-block;
  margin-right: 10px;
}
#controls .value {
  color: #06ffa5;
  font-weight: bold;
  display: inline-block;
  vertical-align: middle;
}
.desktop-only {
  display: block;
}
/* Hide desktop-only controls on touch devices */
@media (hover: none) and (pointer: coarse) {
  .desktop-only {
    display: none !important;
  }
}
/* Hide fire button on desktop devices */
@media (hover: hover) and (pointer: fine) {
  #fire-button {
    display: none !important;
  }
}

/* =============================================================================
   AI TERMINAL CHAT INTERFACE
   ============================================================================= */
#ai-terminal {
  position: fixed;
  bottom: -100%;
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  max-width: 800px;
  height: 35%;
  background: rgba(0, 20, 0, 0.95);
  border: 2px solid #00ff41;
  border-radius: 10px;
  backdrop-filter: blur(15px);
  z-index: 1000;
  transition: bottom 0.5s ease;
  overflow: hidden;
  box-shadow: 
    0 0 30px rgba(0, 255, 65, 0.3),
    inset 0 0 30px rgba(0, 255, 65, 0.1);
}

#ai-terminal.active {
  bottom: 5%;
}

#ai-terminal-header {
  background: rgba(0, 255, 65, 0.2);
  padding: 10px 20px;
  border-bottom: 1px solid #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  color: #00ff41;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#ai-terminal-close {
  background: none;
  border: none;
  color: #ff4444;
  font-size: 18px;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#ai-terminal-close:hover {
  color: #ff6666;
  text-shadow: 0 0 10px #ff4444;
}

#ai-chat-container {
  height: calc(100% - 120px);
  overflow-y: auto;
  padding: 20px;
  font-family: 'Courier New', monospace;
  font-size: 13px;
  line-height: 1.4;
  color: #00ff41;
}

#ai-chat-container::-webkit-scrollbar {
  width: 8px;
}

#ai-chat-container::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
}

#ai-chat-container::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 65, 0.5);
  border-radius: 4px;
}

.chat-message {
  margin-bottom: 15px;
  opacity: 0;
  animation: fadeInMessage 0.3s ease forwards;
}

@keyframes fadeInMessage {
  to { opacity: 1; }
}

.chat-prompt {
  color: #00ff41;
  text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
}

.chat-user {
  color: #54c6ff;
}

.chat-ai {
  color: #00ff41;
  margin-left: 20px;
}

.chat-system {
  color: #ff8800;
  font-style: italic;
}

.chat-error {
  color: #ff4444;
  background: rgba(255, 68, 68, 0.1);
  padding: 10px;
  border-left: 3px solid #ff4444;
  margin: 10px 0;
}

#ai-model-input-container {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.8);
  border-top: 1px solid #00ff41;
  padding: 15px;
  display: flex;
  align-items: center;
}

#ai-input-container {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.8);
  border-top: 1px solid #00ff41;
  padding: 15px;
  display: flex;
  align-items: center;
}

#ai-input-prompt, #ai-model-prompt {
  color: #00ff41;
  font-family: 'Courier New', monospace;
  margin-right: 10px;
  text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
}

#ai-input, #ai-model-input {
  flex: 1;
  background: transparent;
  border: none;
  color: #54c6ff;
  font-family: 'Courier New', monospace;
  font-size: 13px;
  outline: none;
  padding: 5px;
}

#ai-input::placeholder, #ai-model-input::placeholder {
  color: rgba(84, 198, 255, 0.5);
}

.typing-cursor {
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.ai-loading {
  color: #ff8800;
  text-align: center;
  padding: 20px;
}

.loading-animation {
  display: inline-block;
  animation: pulse 1.5s ease-in-out infinite alternate;
}

@keyframes pulse {
  from { opacity: 0.5; text-shadow: 0 0 5px rgba(255, 136, 0, 0.3); }
  to { opacity: 1; text-shadow: 0 0 15px rgba(255, 136, 0, 0.8); }
}

.scan-lines {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 255, 65, 0.03) 2px,
    rgba(0, 255, 65, 0.03) 4px
  );
  pointer-events: none;
}

.glitch-text {
  animation: glitch 2s infinite;
}

@keyframes glitch {
  0%, 90%, 100% { transform: translateX(0); }
  91% { transform: translateX(-2px); }
  92% { transform: translateX(2px); }
  93% { transform: translateX(-1px); }
}
</style>
</head>
<body>
<div id="logo">MissionFocused.ai</div>
<div id="settings-toggle">‚öôÔ∏è</div>
<div id="instructions">panel</div>
<div id="camera-toggle">üì∑</div>
<div id="fire-button">üî¥</div>
<div id="controls">
  <label>Custom Image for Intel Panel</label>
  <input type="file" id="customImageFile" accept="image/*" style="margin-bottom: 10px; width: 100%;">
  
  <label>Use Custom Image</label>
  <input type="checkbox" id="useCustomImage" style="margin-bottom: 15px;">
  
  <label>Panel Z-Depth (Landscape)</label>
  <input type="range" id="panelZDepthLandscape" min="0" max="7" step="0.5" value="6">
  <span class="value" id="panelZDepthLandscapeValue">6</span>
  
  <label>Panel Z-Depth (Portrait)</label>
  <input type="range" id="panelZDepthPortrait" min="0" max="7" step="0.5" value="4.8">
  <span class="value" id="panelZDepthPortraitValue">4.8</span>
  
  <label class="desktop-only">Movement Speed</label>
  <input type="range" id="moveSpeed" min="0.1" max="2" step="0.1" value="0.5" class="desktop-only">
  <span class="value desktop-only" id="moveSpeedValue">0.5</span>
  
  <label class="desktop-only">Mouse Sensitivity</label>
  <input type="range" id="mouseSensitivity" min="0.1" max="6" step="0.1" value="3" class="desktop-only">
  <span class="value desktop-only" id="mouseSensitivityValue">3</span>
  
  <label>Background Sphere Opacity</label>
  <input type="range" id="sphereOpacity" min="0" max="1" step="0.1" value="0.2">
  <span class="value" id="sphereOpacityValue">0.2</span>
  
  <label>Background Sphere Intensity</label>
  <input type="range" id="sphereIntensity" min="0" max="1" step="0.1" value="1">
  <span class="value" id="sphereIntensityValue">1</span>
  
  <label>Fog Opacity</label>
  <input type="range" id="fogOpacity" min="0" max="1" step="0.01" value="0.2">
  <span class="value" id="fogOpacityValue">0.2</span>
  
  <label>Fog Saturation</label>
  <input type="range" id="fogSaturation" min="0" max="1" step="0.1" value="1">
  <span class="value" id="fogSaturationValue">1</span>
  
  <label>Radar Plane Opacity</label>
  <input type="range" id="radarOpacity" min="0" max="1" step="0.1" value="1">
  <span class="value" id="radarOpacityValue">1</span>
  
  <label>Radar Background Alpha</label>
  <input type="range" id="radarBgAlpha" min="0" max="0.2" step="0.01" value="0.2">
  <span class="value" id="radarBgAlphaValue">0.2</span>
  
  <label>Radar Line Alpha</label>
  <input type="range" id="radarLineAlpha" min="0" max="1" step="0.1" value="1">
  <span class="value" id="radarLineAlphaValue">1</span>
  
  <label>Panel Matrix Opacity</label>
  <input type="range" id="panelMatrixOpacity" min="0" max="2" step="0.1" value="2">
  <span class="value" id="panelMatrixOpacityValue">2</span>
  
  <label>Panel Matrix Intensity</label>
  <input type="range" id="panelMatrixIntensity" min="0" max="2" step="0.1" value="2">
  <span class="value" id="panelMatrixIntensityValue">2</span>
  
  <label>Lights Per Glass Layer</label>
  <input type="range" id="lightsPerLayer" min="1" max="5" step="1" value="5">
  <span class="value" id="lightsPerLayerValue">5</span>
  
  <label>Spotlight Intensity</label>
  <input type="range" id="spotlightIntensity" min="5" max="50" step="5" value="5">
  <span class="value" id="spotlightIntensityValue">5</span>
  
  <label>Content Panel Background</label>
  <input type="range" id="panelBgOpacity" min="0" max="1" step="0.1" value="0">
  <span class="value" id="panelBgOpacityValue">0</span>
  
  <label>Content Panel Text</label>
  <input type="range" id="panelTextOpacity" min="0" max="1" step="0.1" value="0.9">
  <span class="value" id="panelTextOpacityValue">0.9</span>
</div>

<!-- AI Terminal Chat Interface -->
<div id="ai-terminal">
  <div id="ai-terminal-header">
    <div>MissionFocused.ai Neural Interface v2.1.7</div>
    <button id="ai-terminal-close">√ó</button>
  </div>
  <div id="ai-chat-container">
    <div class="scan-lines"></div>
    <div id="model-selector">
      <div style="color: #00ff41; font-weight: bold; margin-bottom: 20px;">MissionFocused.ai Neural Interface v2.1.7</div>
      <div style="color: #ff8800; margin-bottom: 15px;">[SYSTEM] Select AI consciousness substrate:</div>
      <div id="model-options" style="margin-left: 20px; line-height: 1.8;">
        <!-- Dynamic model options populated by JavaScript -->
      </div>
      <div style="color: #ff8800; margin-top: 20px; margin-bottom: 10px;">Enter selection [1-3]:</div>
    </div>
  </div>
  <div id="ai-model-input-container">
    <span id="ai-model-prompt">mf.ai:~$</span>
    <input type="text" id="ai-model-input" placeholder="1" autocomplete="off" maxlength="1">
  </div>
  <div id="ai-input-container" style="display: none;">
    <span id="ai-input-prompt">mf.ai:~$</span>
    <input type="text" id="ai-input" placeholder="Ask about nonprofit back office automation..." autocomplete="off">
  </div>
</div>

<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Scene setup with darker fog for spotlight drama
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 3, 40); // Thicker, closer fog for more dramatic lighting

// Original camera position (panels will always animate to this position)
const ORIGINAL_CAMERA_POSITION = new THREE.Vector3(0, 3, 10);
const ORIGINAL_CAMERA_TARGET = new THREE.Vector3(0, 2, 0);

// Camera movement variables
let moveSpeedValue = 0.5;
let mouseSensitivityValue = 3;

// Movement state
const keys = {
  w: false,
  a: false,
  s: false,
  d: false
};
let mouseX = 0, mouseY = 0;
let isPointerLocked = false;
let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let touchStartX = 0;
let touchStartY = 0;
let isCameraFree = false;

// Camera boundaries
const CAMERA_BOUNDS = {
  x: { min: -20, max: 20 },
  y: { min: 1, max: 8 },
  z: { min: -15, max: 12 }
};

// Lighting control variables
let sphereOpacityValue = 0.2;
let sphereIntensityValue = 1;
let fogOpacityValue = 0.2;
let fogSaturationValue = 1;
let radarOpacityValue = 1;
let radarBgAlphaValue = 0.2;
let radarLineAlphaValue = 1;
let panelMatrixOpacityValue = 2;
let panelMatrixIntensityValue = 2;
let lightsPerLayerValue = 5;
let spotlightIntensityValue = 5;

// Custom image variables
let useCustomImageValue = false;
let customImageTexture = null;
let originalImageAspectRatio = 1;
let panelBgOpacityValue = 0;
let panelTextOpacityValue = 0.9;
let panelZDepthLandscapeValue = 6;
let panelZDepthPortraitValue = 4.8;

// Setup control event listeners
function setupControls() {
  // Camera controls
  const moveSpeed = document.getElementById('moveSpeed');
  const mouseSensitivity = document.getElementById('mouseSensitivity');
  
  moveSpeed.addEventListener('input', (e) => {
    moveSpeedValue = parseFloat(e.target.value);
    document.getElementById('moveSpeedValue').textContent = moveSpeedValue;
  });
  
  mouseSensitivity.addEventListener('input', (e) => {
    mouseSensitivityValue = parseFloat(e.target.value);
    document.getElementById('mouseSensitivityValue').textContent = mouseSensitivityValue;
  });
  
  // Lighting controls
  const sphereOpacity = document.getElementById('sphereOpacity');
  const sphereIntensity = document.getElementById('sphereIntensity');
  const fogOpacity = document.getElementById('fogOpacity');
  const fogSaturation = document.getElementById('fogSaturation');
  
  sphereOpacity.addEventListener('input', (e) => {
    sphereOpacityValue = parseFloat(e.target.value);
    document.getElementById('sphereOpacityValue').textContent = sphereOpacityValue;
  });
  
  sphereIntensity.addEventListener('input', (e) => {
    sphereIntensityValue = parseFloat(e.target.value);
    document.getElementById('sphereIntensityValue').textContent = sphereIntensityValue;
  });
  
  fogOpacity.addEventListener('input', (e) => {
    fogOpacityValue = parseFloat(e.target.value);
    document.getElementById('fogOpacityValue').textContent = fogOpacityValue;
  });
  
  fogSaturation.addEventListener('input', (e) => {
    fogSaturationValue = parseFloat(e.target.value);
    document.getElementById('fogSaturationValue').textContent = fogSaturationValue;
  });
  
  const radarOpacity = document.getElementById('radarOpacity');
  const radarBgAlpha = document.getElementById('radarBgAlpha');
  const radarLineAlpha = document.getElementById('radarLineAlpha');
  
  radarOpacity.addEventListener('input', (e) => {
    radarOpacityValue = parseFloat(e.target.value);
    document.getElementById('radarOpacityValue').textContent = radarOpacityValue;
  });
  
  radarBgAlpha.addEventListener('input', (e) => {
    radarBgAlphaValue = parseFloat(e.target.value);
    document.getElementById('radarBgAlphaValue').textContent = radarBgAlphaValue;
  });
  
  radarLineAlpha.addEventListener('input', (e) => {
    radarLineAlphaValue = parseFloat(e.target.value);
    document.getElementById('radarLineAlphaValue').textContent = radarLineAlphaValue;
  });
  
  const panelMatrixOpacity = document.getElementById('panelMatrixOpacity');
  const panelMatrixIntensity = document.getElementById('panelMatrixIntensity');
  
  panelMatrixOpacity.addEventListener('input', (e) => {
    panelMatrixOpacityValue = parseFloat(e.target.value);
    document.getElementById('panelMatrixOpacityValue').textContent = panelMatrixOpacityValue;
  });
  
  panelMatrixIntensity.addEventListener('input', (e) => {
    panelMatrixIntensityValue = parseFloat(e.target.value);
    document.getElementById('panelMatrixIntensityValue').textContent = panelMatrixIntensityValue;
  });
  
  const lightsPerLayer = document.getElementById('lightsPerLayer');
  const spotlightIntensity = document.getElementById('spotlightIntensity');
  
  lightsPerLayer.addEventListener('input', (e) => {
    lightsPerLayerValue = parseInt(e.target.value);
    document.getElementById('lightsPerLayerValue').textContent = lightsPerLayerValue;
    // Recreate lights with new count
    recreateLights();
  });
  
  spotlightIntensity.addEventListener('input', (e) => {
    spotlightIntensityValue = parseFloat(e.target.value);
    document.getElementById('spotlightIntensityValue').textContent = spotlightIntensityValue;
  });
  
  // Custom image controls
  const customImageFile = document.getElementById('customImageFile');
  const useCustomImage = document.getElementById('useCustomImage');
  
  customImageFile.addEventListener('change', (e) => {
    console.log('üñºÔ∏è File picker changed:', e.target.files);
    const file = e.target.files[0];
    if (file && file.type.startsWith('image/')) {
      console.log('‚úÖ Valid image file selected:', file.name, file.type);
      const reader = new FileReader();
      reader.onload = (event) => {
        console.log('üìñ FileReader loaded, creating image...');
        const img = new Image();
        img.onload = () => {
          console.log('üñºÔ∏è Image loaded! Dimensions:', img.width, 'x', img.height);
          // Store aspect ratio
          originalImageAspectRatio = img.width / img.height;
          console.log('üìê Aspect ratio:', originalImageAspectRatio);
          
          // Create texture with proper aspect ratio preservation
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Use reasonable canvas size while maintaining aspect ratio
          const maxCanvasSize = 1024;
          let canvasWidth, canvasHeight;
          
          if (img.width > img.height) {
            canvasWidth = Math.min(maxCanvasSize, img.width);
            canvasHeight = canvasWidth / originalImageAspectRatio;
          } else {
            canvasHeight = Math.min(maxCanvasSize, img.height);
            canvasWidth = canvasHeight * originalImageAspectRatio;
          }
          
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          
          // Clear canvas and draw image
          ctx.clearRect(0, 0, canvasWidth, canvasHeight);
          ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
          
          customImageTexture = new THREE.CanvasTexture(canvas);
          customImageTexture.minFilter = THREE.LinearFilter;
          customImageTexture.magFilter = THREE.LinearFilter;
          customImageTexture.wrapS = THREE.ClampToEdgeWrapping;
          customImageTexture.wrapT = THREE.ClampToEdgeWrapping;
          console.log('üé® Texture created:', customImageTexture);
          console.log('üé® Canvas dimensions:', canvasWidth, 'x', canvasHeight);
        };
        img.onerror = () => {
          console.error('‚ùå Failed to load image');
        };
        img.src = event.target.result;
      };
      reader.onerror = () => {
        console.error('‚ùå FileReader error');
      };
      reader.readAsDataURL(file);
    } else {
      console.log('‚ùå No valid image file selected');
    }
  });
  
  useCustomImage.addEventListener('change', (e) => {
    useCustomImageValue = e.target.checked;
    console.log('üîÑ Toggle changed - Use custom image:', useCustomImageValue);
    console.log('üñºÔ∏è Custom texture available:', !!customImageTexture);
    console.log('üëÅÔ∏è Current focus panel:', currentFocus);
    
    // Always recreate the intel panel when toggle changes
    console.log('üîÑ Recreating intel panel...');
    recreateIntelPanel();
  });
  
  const panelBgOpacity = document.getElementById('panelBgOpacity');
  const panelTextOpacity = document.getElementById('panelTextOpacity');
  
  panelBgOpacity.addEventListener('input', (e) => {
    panelBgOpacityValue = parseFloat(e.target.value);
    document.getElementById('panelBgOpacityValue').textContent = panelBgOpacityValue;
  });
  
  panelTextOpacity.addEventListener('input', (e) => {
    panelTextOpacityValue = parseFloat(e.target.value);
    document.getElementById('panelTextOpacityValue').textContent = panelTextOpacityValue;
  });
  
  const panelZDepthLandscape = document.getElementById('panelZDepthLandscape');
  const panelZDepthPortrait = document.getElementById('panelZDepthPortrait');
  
  panelZDepthLandscape.addEventListener('input', (e) => {
    panelZDepthLandscapeValue = parseFloat(e.target.value);
    document.getElementById('panelZDepthLandscapeValue').textContent = panelZDepthLandscapeValue;
  });
  
  panelZDepthPortrait.addEventListener('input', (e) => {
    panelZDepthPortraitValue = parseFloat(e.target.value);
    document.getElementById('panelZDepthPortraitValue').textContent = panelZDepthPortraitValue;
  });
}

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// Initialize camera position
camera.position.copy(ORIGINAL_CAMERA_POSITION);
camera.lookAt(ORIGINAL_CAMERA_TARGET);

// Content for screens
const screenContent = [
  {
    title: "MISSION FOCUSED v1",
    content: "Automate to Amplify Your Mission\n\nMissionFocused.ai streamlines your nonprofit's back office so you can focus on impact.",
    color: 0x54c6ff
  },
  {
    title: "ABOUT US",
    content: "Born from a passion for nonprofit efficiency, MissionFocused.ai helps organizations slash overhead and channel more resources directly to mission.\n\nOur founders are veterans of the charity world who know the constraints of limited staff, outdated software, and rigid compliance.",
    color: 0xff5bc3
  },
  {
    title: "PLATFORM SYSTEMS",
    content: "‚Ä¢ No-Code Workflows\n‚Ä¢ Composable Data Hub\n‚Ä¢ AI Document Copilot\n‚Ä¢ Audit-Ready Ledger\n\nDrag-and-drop builders, unified APIs, OCR + LLMs, and immutable transaction logging.",
    color: 0x8c62ff
  },
  {
    title: "SERVICES FOR NONPROFITS",
    content: "‚Ä¢ Configure Finance AI Agents\n‚Ä¢ CRM migrations & donor segmentation\n‚Ä¢ Custom AI assistants for case management\n‚Ä¢ Grant compliance & reporting automation",
    color: 0x06ffa5
  },
  {
    title: "SECURITY PROTOCOLS",
    content: "NEVER LOSE INFORMATION\nCollect web snippets, docs, and emails from any device. Instant, secure sync.\n\nHARDENED SECURITY\nEnd-to-end encryption. Export anytime, integrate with Zapier, self-host on request.",
    color: 0x54c6ff
  },
  {
    title: "INTEL ON MISSION FOCUSED",
    content: "Q: Is MissionFocused.ai just for US nonprofits?\nA: No ‚Äî multi-currency and GDPR compliant.\n\nQ: Can we deploy on-prem?\nA: Yes, via Kubernetes operator.\n\nQ: Discounts?\nA: Early adopters receive lifetime 30% off.",
    color: 0xff5bc3
  },
  {
    title: "CONTACT US",
    content: "CONTACT MISSION CONTROL\n\nhello@missionfocused.ai\n\nWe'd love to learn about your mission and help you achieve maximum impact with minimal overhead.",
    color: 0x8c62ff
  }
];

// Minimal ambient lighting to make spotlights dramatically visible
const ambientLight = new THREE.AmbientLight(0x0a0a1a, 0.1);
scene.add(ambientLight);

// Dynamic lighting system for glassmorphism effects
const lights = [];
const baseColors = [0xff0080, 0x0080ff, 0x80ff00, 0xff8000]; // Bold, saturated colors

// Function to create lights based on current settings
function createLights() {
  // Clear existing lights
  lights.forEach(light => scene.remove(light));
  lights.length = 0;
  
  // Create lights for each glass layer
  for (let layer = 0; layer < 4; layer++) {
    for (let lightIndex = 0; lightIndex < lightsPerLayerValue; lightIndex++) {
      const light = new THREE.PointLight(
        baseColors[layer], 
        spotlightIntensityValue,
        80
      );
      
      // Position lights in small constrained boxes between glass panes
      const zDepth = -9 - (layer * 3) + (lightIndex * 0.5); // Slight Z offset per light in layer
      light.position.set(
        (Math.random() - 0.5) * 20, // x = ¬±10 (smaller box than glass)
        3 + Math.random() * 4,      // y = 3-7 (constrained height)
        zDepth + Math.random() * 1  // slight z variation within layer
      );
      
      // Store layer info for animation
      light.userData = {
        layer: layer,
        lightIndex: lightIndex,
        baseZ: zDepth
      };
      
      scene.add(light);
      lights.push(light);
    }
  }
}

// Function to recreate lights when settings change
function recreateLights() {
  createLights();
}

// Initial light creation
createLights();

// Radar system
const radarCanvas = document.createElement('canvas');
radarCanvas.width = 512;
radarCanvas.height = 512;
const radarCtx = radarCanvas.getContext('2d');

const radarGeometry = new THREE.PlaneGeometry(50, 25); // Full grid width, half height
const radarTexture = new THREE.CanvasTexture(radarCanvas);
const radarMaterial = new THREE.MeshBasicMaterial({
  map: radarTexture,
  transparent: true,
  opacity: 0.8, // Slightly more opaque to maintain readability while showing glass effects
  side: THREE.DoubleSide,
  alphaTest: 0.1 // Allow better alpha blending with background glass effects
});

const radarMesh = new THREE.Mesh(radarGeometry, radarMaterial);
radarMesh.position.set(0, -2, -25); // Animation center at floor level
radarMesh.rotation.x = 0; // Vertical on wall
scene.add(radarMesh);

// Bogey tracking data
const bogeys = [
  { x: 0.3, y: 0.2, speed: 0.02, direction: Math.PI / 4, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.02 },
  { x: -0.4, y: 0.1, speed: 0.015, direction: -Math.PI / 3, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.015 },
  { x: 0.1, y: -0.35, speed: 0.025, direction: Math.PI * 0.8, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.025 },
  { x: -0.2, y: -0.3, speed: 0.018, direction: Math.PI * 1.2, lastPing: 0, lastDirectionChange: 0, baseSpeed: 0.018 }
];

let radarRotation = 0;

// Shared panel matrix system
const panelMatrixCanvas = document.createElement('canvas');
panelMatrixCanvas.width = 1024;
panelMatrixCanvas.height = 1024;
const panelMatrixCtx = panelMatrixCanvas.getContext('2d');

// Panel matrix columns
const panelMatrixColumns = [];
const columnCount = 80; // More columns for larger canvas

// Initialize panel matrix
function initializePanelMatrix() {
  for (let i = 0; i < columnCount; i++) {
    panelMatrixColumns.push({
      x: (i * 12) + Math.random() * 4,
      y: Math.random() * -1000,
      speed: 0.5 + Math.random() * 1,
      chars: [],
      lastChar: 0
    });
  }
}

// Update shared panel matrix
function updatePanelMatrix() {
  // Clear canvas
  panelMatrixCtx.clearRect(0, 0, panelMatrixCanvas.width, panelMatrixCanvas.height);
  
  panelMatrixColumns.forEach(column => {
    // Move column down
    column.y += column.speed;
    
    // Add new character occasionally
    column.lastChar += 1;
    if (column.lastChar > 15 + Math.random() * 30) {
      column.chars.push({
        char: matrixChars[Math.floor(Math.random() * matrixChars.length)],
        y: column.y,
        alpha: 1
      });
      column.lastChar = 0;
    }
    
    // Update and draw characters
    for (let j = column.chars.length - 1; j >= 0; j--) {
      const char = column.chars[j];
      
      // Character fades as it gets older
      const distanceFromHead = column.y - char.y;
      char.alpha = Math.max(0, 1 - (distanceFromHead / 120));
      
      if (char.alpha > 0) {
        // Calculate alpha with intensity control
        const finalAlpha = char.alpha * panelMatrixIntensityValue;
        
        if (j === column.chars.length - 1) {
          // Head character - brighter
          panelMatrixCtx.fillStyle = `rgba(150, 255, 150, ${finalAlpha})`;
          panelMatrixCtx.font = 'bold 14px monospace';
        } else {
          // Trail characters
          panelMatrixCtx.fillStyle = `rgba(100, 200, 100, ${finalAlpha * 0.7})`;
          panelMatrixCtx.font = '12px monospace';
        }
        
        panelMatrixCtx.fillText(char.char, column.x, char.y);
      } else {
        // Remove faded characters
        column.chars.splice(j, 1);
      }
    }
    
    // Reset column when it goes off screen
    if (column.y > panelMatrixCanvas.height + 100) {
      column.y = Math.random() * -300;
      column.chars = [];
    }
  });
}

// Radar drawing function
function updateRadar() {
  const centerX = radarCanvas.width / 2;
  const centerY = radarCanvas.height / 2;
  const radius = centerX - 20;
  
  // Clear canvas (transparent background)
  radarCtx.clearRect(0, 0, radarCanvas.width, radarCanvas.height);
  
  // Set up clipping to show only top half
  radarCtx.save();
  radarCtx.beginPath();
  radarCtx.rect(0, 0, radarCanvas.width, radarCanvas.height / 2);
  radarCtx.clip();
  
  // Draw radar circles (glassmorphic) with controllable alpha
  radarCtx.strokeStyle = `rgba(84, 198, 255, ${radarLineAlphaValue})`;
  radarCtx.lineWidth = 1;
  for (let i = 1; i <= 4; i++) {
    radarCtx.beginPath();
    radarCtx.arc(centerX, centerY, (radius / 4) * i, 0, Math.PI * 2);
    radarCtx.stroke();
  }
  
  // Draw crosshairs
  radarCtx.beginPath();
  radarCtx.moveTo(centerX - radius, centerY);
  radarCtx.lineTo(centerX + radius, centerY);
  radarCtx.moveTo(centerX, centerY - radius);
  radarCtx.lineTo(centerX, centerY + radius);
  radarCtx.stroke();
  
  // Update bogey positions with random movement
  bogeys.forEach(bogey => {
    // Random direction changes
    bogey.lastDirectionChange += 1;
    if (bogey.lastDirectionChange > 30 + Math.random() * 120) { // Change direction every 30-150 frames
      bogey.direction += (Math.random() - 0.5) * Math.PI * 0.8; // Random turn up to ¬±72 degrees
      bogey.lastDirectionChange = 0;
    }
    
    // Random speed variations
    bogey.speed = bogey.baseSpeed * (0.5 + Math.random() * 1.5); // 50% to 200% of base speed
    
    // Add small random jitter to movement
    const jitterX = (Math.random() - 0.5) * 0.005;
    const jitterY = (Math.random() - 0.5) * 0.005;
    
    // Move bogey
    bogey.x += Math.cos(bogey.direction) * bogey.speed + jitterX;
    bogey.y += Math.sin(bogey.direction) * bogey.speed + jitterY;
    
    // Keep bogeys in bounds with more random bouncing
    const distance = Math.sqrt(bogey.x * bogey.x + bogey.y * bogey.y);
    if (distance > 0.9) {
      // Random bounce angle instead of simple reverse
      const bounceAngle = Math.atan2(bogey.y, bogey.x) + Math.PI + (Math.random() - 0.5) * Math.PI * 0.5;
      bogey.direction = bounceAngle;
      bogey.lastDirectionChange = 0; // Reset direction change timer
    }
    
    // Limit to radar range
    if (distance > 0.95) {
      bogey.x *= 0.9;
      bogey.y *= 0.9;
    }
  });
  
  // Draw sweep line (rotating)
  radarRotation += 0.06;
  const sweepX = centerX + Math.cos(radarRotation) * radius;
  const sweepY = centerY + Math.sin(radarRotation) * radius;
  
  // Sweep trail effect
  const gradient = radarCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
  gradient.addColorStop(0, 'rgba(0, 255, 100, 0.8)');
  gradient.addColorStop(0.3, 'rgba(0, 255, 100, 0.4)');
  gradient.addColorStop(1, 'rgba(0, 255, 100, 0)');
  
  radarCtx.save();
  radarCtx.translate(centerX, centerY);
  radarCtx.rotate(radarRotation);
  radarCtx.beginPath();
  radarCtx.moveTo(0, 0);
  radarCtx.arc(0, 0, radius, -Math.PI / 6, Math.PI / 6);
  radarCtx.closePath();
  radarCtx.fillStyle = gradient;
  radarCtx.fill();
  radarCtx.restore();
  
  // Draw sweep line
  radarCtx.strokeStyle = 'rgba(0, 255, 100, 1)';
  radarCtx.lineWidth = 2;
  radarCtx.beginPath();
  radarCtx.moveTo(centerX, centerY);
  radarCtx.lineTo(sweepX, sweepY);
  radarCtx.stroke();
  
  // Draw bogeys
  bogeys.forEach(bogey => {
    const bogeyX = centerX + bogey.x * radius;
    const bogeyY = centerY + bogey.y * radius;
    
    // Calculate if bogey should be highlighted (recently swept)
    const bogeyAngle = Math.atan2(bogey.y, bogey.x);
    let angleDiff = Math.abs(radarRotation - bogeyAngle);
    if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
    
    if (angleDiff < 0.2) {
      bogey.lastPing = time;
    }
    
    // Draw bogey with fade effect
    const timeSincePing = time - bogey.lastPing;
    const alpha = Math.max(0, 1 - timeSincePing * 0.3);
    
    if (alpha > 0) {
      radarCtx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
      radarCtx.beginPath();
      radarCtx.arc(bogeyX, bogeyY, 4, 0, Math.PI * 2);
      radarCtx.fill();
      
      // Draw target rings
      radarCtx.strokeStyle = `rgba(255, 100, 100, ${alpha * 0.5})`;
      radarCtx.lineWidth = 1;
      radarCtx.beginPath();
      radarCtx.arc(bogeyX, bogeyY, 8, 0, Math.PI * 2);
      radarCtx.stroke();
    }
  });
  
  // Restore canvas context (remove clipping)
  radarCtx.restore();
  
  radarTexture.needsUpdate = true;
}

// Floor grid
const gridHelper = new THREE.GridHelper(50, 50, 0x1a1a2e, 0x1a1a2e);
gridHelper.position.y = -2;
scene.add(gridHelper);

// 4 massive glass panes between content and radar for seamless glassmorphism
const glassPanels = [];
const glassColors = [0x800040, 0x004080, 0x408000, 0x804000]; // Match light colors but darker

for (let i = 0; i < 4; i++) {
  const glassPanel = new THREE.Mesh(
    new THREE.PlaneGeometry(150, 130), // MASSIVE size so edges are never visible from normal view
    new THREE.MeshPhysicalMaterial({
      color: glassColors[i],
      metalness: 0.3, // Higher metalness for more intense reflections
      roughness: 0.01, // Even smoother for maximum reflection
      transparent: true,
      opacity: 0.35, // Higher opacity to make light effects more visible
      transmission: 0.95, // Slightly reduced for more dramatic light interaction
      ior: 2.0 + i * 0.3, // Even more dramatic IOR differences for each pane
      side: THREE.DoubleSide
    })
  );
  
  // Position each pane between content panels (z=-5) and radar (z=-25)
  glassPanel.position.set(
    0,                    // Centered
    15,                   // Position to cover the viewing area (bottom at y=-25, top at y=55)
    -8 - (i * 3)         // z = -8, -11, -14, -17 (between content at -5 and radar at -25)
  );
  
  scene.add(glassPanel);
  glassPanels.push(glassPanel);
}

// Darker background sphere to make spotlights more dramatic
const backgroundSphere = new THREE.Mesh(
  new THREE.SphereGeometry(120, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0x1a0820, // Much darker purple
    transparent: true,
    opacity: sphereOpacityValue * 0.5, // Half opacity for darker background
    side: THREE.BackSide
  })
);
backgroundSphere.position.set(0, 0, -55); // Further back to encompass glass layers
scene.add(backgroundSphere);

// Create screens
const screens = [];
const screenGroups = [];
const panelCanvases = []; // Store panel canvases for animation updates

function createScreen(content, index) {
  const group = new THREE.Group();
  
  const geometry = new THREE.PlaneGeometry(4, 3);
  const material = new THREE.MeshPhongMaterial({
    color: content.color,
    emissive: content.color,
    emissiveIntensity: 0.2,
    transparent: true,
    opacity: panelBgOpacityValue,
    side: THREE.DoubleSide
  });
  
  const screen = new THREE.Mesh(geometry, material);
  
  // Create texture (either text or custom image)
  let texture;
  let panelInfo = null;
  let customGeometry = null; // Declare in outer scope
  
  // Check if this is the intel panel (index 5) and custom image is enabled
  console.log('üîç createScreen called for index:', index);
  console.log('üîç useCustomImageValue:', useCustomImageValue);
  console.log('üîç customImageTexture exists:', !!customImageTexture);
  
  if (index === 5 && useCustomImageValue && customImageTexture) {
    console.log('üñºÔ∏è Using custom image for intel panel');
    // Use custom image texture
    texture = customImageTexture.clone();
    
    // Calculate geometry size to maintain aspect ratio while keeping similar visual scale
    const baseArea = 4 * 3; // 12 square units - maintain similar visual presence
    const maxDimension = 4.5; // Prevent panels from getting too large
    
    let newWidth, newHeight;
    
    if (originalImageAspectRatio >= 1) {
      // Landscape or square image - scale based on area but cap width
      newWidth = Math.min(maxDimension, Math.sqrt(baseArea * originalImageAspectRatio));
      newHeight = newWidth / originalImageAspectRatio;
    } else {
      // Portrait image - scale based on area but cap height  
      newHeight = Math.min(maxDimension, Math.sqrt(baseArea / originalImageAspectRatio));
      newWidth = newHeight * originalImageAspectRatio;
    }
    
    console.log('üìè Image aspect ratio:', originalImageAspectRatio);
    console.log('üìè Panel dimensions:', newWidth.toFixed(2), 'x', newHeight.toFixed(2));
    console.log('üìè Image orientation:', originalImageAspectRatio >= 1 ? 'Landscape/Square' : 'Portrait');
    
    // Create new geometry to maintain aspect ratio
    customGeometry = new THREE.PlaneGeometry(newWidth, newHeight);
    screen.geometry = customGeometry;
    
    // We'll use customGeometry for the textMesh too
    console.log('üìè Geometry updated with dimensions:', newWidth.toFixed(2), 'x', newHeight.toFixed(2));
  } else {
    console.log('üìù Using text texture for panel');
    // Create text texture
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 384;
    const ctx = canvas.getContext('2d');
    
    // Store canvas info for animation updates
    panelInfo = {
      canvas: canvas,
      ctx: ctx,
      texture: null,
      content: content,
      index: index
    };
    
    // Initial draw - will be updated in animation loop
    // Draw background (subtle darkness for readability while showing matrix)
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    texture = new THREE.CanvasTexture(canvas);
    panelInfo.texture = texture;
  }
  
  const textMaterial = new THREE.MeshBasicMaterial({ 
    map: texture, 
    transparent: true,
    opacity: panelTextOpacityValue
  });
  
  // Use custom geometry if we created one, otherwise use default
  const meshGeometry = customGeometry || geometry;
  const textMesh = new THREE.Mesh(meshGeometry, textMaterial);
  textMesh.position.z = 0.01;
  
  // Store panel info for updates (only for text panels)
  if (panelInfo) {
    panelCanvases.push(panelInfo);
  }
  
  group.add(screen);
  group.add(textMesh);
  
  // Position screens in two rows
  const row = index < 4 ? 0 : 1;
  const col = index < 4 ? index : index - 4;
  const colsInRow = index < 4 ? 4 : 3;
  
  const xSpacing = 9;
  const ySpacing = 4;
  const xOffset = -(colsInRow - 1) * xSpacing / 2;
  
  group.position.x = xOffset + col * xSpacing;
  group.position.y = row === 0 ? 5 : 1;
  group.position.z = -5;
  
  // Angle panels slightly toward viewer
  group.rotation.y = -group.position.x * 0.03;
  
  // Store original transform and material references
  group.userData = {
    originalPosition: group.position.clone(),
    originalRotation: group.rotation.clone(),
    originalScale: group.scale.clone(),
    targetPosition: new THREE.Vector3(ORIGINAL_CAMERA_POSITION.x, 2.5, 6), // Panels fly to original camera position
    targetRotation: new THREE.Euler(0, 0, 0),
    targetScale: new THREE.Vector3(1.2, 1.2, 1.2),
    screen: screen,
    screenMaterial: material,
    textMaterial: textMaterial,
    index: index,
    animating: false,
    focused: false
  };
  
  scene.add(group);
  screens.push(screen);
  screenGroups.push(group);
  
  return group;
}

// Function to recreate just the intel panel (index 5)
function recreateIntelPanel() {
  console.log('üîÑ recreateIntelPanel called');
  const intelIndex = 5;
  const group = screenGroups[intelIndex];
  console.log('üéØ Found existing group:', !!group);
  
  if (group) {
    console.log('üóëÔ∏è Removing old group from scene');
    // Remove the old group
    scene.remove(group);
    
    // Remove from arrays
    screens.splice(intelIndex, 1);
    screenGroups.splice(intelIndex, 1);
    
    // Find and remove the panel canvas info
    const panelCanvasIndex = panelCanvases.findIndex(panel => panel.index === intelIndex);
    if (panelCanvasIndex !== -1) {
      console.log('üóëÔ∏è Removing panel canvas info');
      panelCanvases.splice(panelCanvasIndex, 1);
    }
    
    console.log('üî® Creating new panel...');
    // Create new panel
    const newGroup = createScreen(screenContent[intelIndex], intelIndex);
    
    console.log('üì¶ Inserting new group into arrays');
    // Insert back into arrays at the correct position
    screens.splice(intelIndex, 0, newGroup.userData.screen);
    screenGroups.splice(intelIndex, 0, newGroup);
    
    // Update collision detection targets to include the new panel geometry
    paintballSystem.setupCollisionTargets();
    console.log('üéØ Updated collision targets for new geometry');
    
    console.log('‚úÖ Intel panel recreation complete');
  } else {
    console.log('‚ùå No existing group found to recreate');
  }
}

// Create all screens
screenContent.forEach((content, i) => createScreen(content, i));

// =============================================================================
// PAINTBALL SYSTEM - Encapsulated paintball physics and effects
// =============================================================================

class PaintballSystem {
  constructor(scene, camera, renderer) {
    this.scene = scene;
    this.camera = camera;
    this.renderer = renderer;
    
    // Paintball physics
    this.gravity = -9.8; // Realistic gravity
    this.paintballs = []; // Active paintballs
    this.paintSplatters = []; // Paint effects on surfaces
    
    // Paint colors
    this.paintColors = [
      0xff0040, // Hot pink
      0x00ff40, // Bright green  
      0x0040ff, // Electric blue
      0xff8000, // Orange
      0x8000ff, // Purple
      0xffff00  // Yellow
    ];
    
    // Collision detection
    this.raycaster = new THREE.Raycaster();
    this.collisionTargets = [];
    
    // Paint system
    this.paintCanvases = new Map(); // Store paint canvases for each surface
    
    this.setupCollisionTargets();
  }
  
  setupCollisionTargets() {
    // Add all panels as collision targets
    this.collisionTargets = [
      ...screenGroups.map(group => group),
      ...glassPanels,
      gridHelper
    ];
  }
  
  launch(startPosition, direction, power = 15) {
    if (!isCameraFree) return; // Only allow when camera is free
    
    const paintball = {
      id: Date.now() + Math.random(),
      mesh: this.createPaintballMesh(),
      velocity: direction.clone().multiplyScalar(power),
      startTime: performance.now(),
      color: this.paintColors[Math.floor(Math.random() * this.paintColors.length)],
      hasCollided: false
    };
    
    paintball.mesh.position.copy(startPosition);
    this.scene.add(paintball.mesh);
    this.paintballs.push(paintball);
  }
  
  createPaintballMesh() {
    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
    const material = new THREE.MeshBasicMaterial({ 
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    return new THREE.Mesh(geometry, material);
  }
  
  update(deltaTime) {
    for (let i = this.paintballs.length - 1; i >= 0; i--) {
      const paintball = this.paintballs[i];
      
      if (paintball.hasCollided) {
        // Remove collided paintballs after a short delay
        this.scene.remove(paintball.mesh);
        this.paintballs.splice(i, 1);
        continue;
      }
      
      // Physics update
      const elapsed = (performance.now() - paintball.startTime) / 1000;
      
      // Apply gravity to velocity
      paintball.velocity.y += this.gravity * deltaTime;
      
      // Calculate new position
      const newPosition = paintball.mesh.position.clone();
      newPosition.add(paintball.velocity.clone().multiplyScalar(deltaTime));
      
      // Check for collision
      const collision = this.checkCollision(paintball.mesh.position, newPosition);
      
      if (collision) {
        this.handleCollision(paintball, collision);
        paintball.hasCollided = true;
      } else {
        // Update position
        paintball.mesh.position.copy(newPosition);
        paintball.mesh.material.color.setHex(paintball.color);
        
        // Remove if too far away or too old
        if (newPosition.y < -10 || elapsed > 10) {
          this.scene.remove(paintball.mesh);
          this.paintballs.splice(i, 1);
        }
      }
    }
  }
  
  checkCollision(currentPos, newPos) {
    // Cast ray from current position to new position
    const direction = newPos.clone().sub(currentPos).normalize();
    const distance = currentPos.distanceTo(newPos);
    
    this.raycaster.set(currentPos, direction);
    this.raycaster.far = distance;
    
    const intersects = this.raycaster.intersectObjects(this.collisionTargets, true);
    
    if (intersects.length > 0) {
      return intersects[0];
    }
    
    return null;
  }
  
  handleCollision(paintball, collision) {
    const hitPoint = collision.point;
    const hitObject = collision.object;
    
    // Get surface normal - handle special cases like GridHelper
    let surfaceNormal;
    if (collision.face && collision.face.normal) {
      // Standard mesh collision
      surfaceNormal = collision.face.normal.clone();
    } else if (hitObject.isGridHelper || hitObject.type === 'GridHelper') {
      // GridHelper collision - assume upward normal
      surfaceNormal = new THREE.Vector3(0, 1, 0);
    } else {
      // Fallback - calculate normal from hit point
      const center = new THREE.Vector3();
      hitObject.getWorldPosition(center);
      surfaceNormal = hitPoint.clone().sub(center).normalize();
      
      // If still invalid, use upward normal
      if (surfaceNormal.length() === 0) {
        surfaceNormal = new THREE.Vector3(0, 1, 0);
      }
    }
    
    // Create paint splatter effect
    this.createPaintSplatter(hitPoint, surfaceNormal, paintball.color, hitObject);
    
    // Position paintball at collision point
    paintball.mesh.position.copy(hitPoint);
  }
  
  createPaintSplatter(position, normal, color, hitObject) {
    // Create organic splatter geometry - order of magnitude smaller
    const baseSize = 0.02 + Math.random() * 0.03; // Much smaller: 0.02-0.05
    const geometry = this.createOrganicSplatterGeometry(baseSize);
    
    // Create paint material
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const splatter = new THREE.Mesh(geometry, material);
    
    // Position splatter flush to surface with proper orientation
    splatter.position.copy(position);
    
    // Proper orientation for flat surfaces - avoid lookAt issues
    if (Math.abs(normal.y) > 0.9) {
      // Floor/ceiling - normal is mostly up/down
      splatter.rotation.x = normal.y > 0 ? -Math.PI/2 : Math.PI/2;
      splatter.rotation.y = 0;
      splatter.rotation.z = Math.random() * Math.PI * 2; // Random rotation around Y axis
    } else if (Math.abs(normal.z) > 0.7) {
      // Front/back faces - normal is mostly forward/backward
      splatter.rotation.x = 0;
      splatter.rotation.y = normal.z > 0 ? 0 : Math.PI;
      splatter.rotation.z = Math.random() * Math.PI * 2; // Random rotation around Z axis
    } else {
      // Side faces - use lookAt as fallback but ensure flat positioning
      const up = new THREE.Vector3(0, 1, 0);
      splatter.lookAt(position.clone().add(normal));
      splatter.rotateZ(Math.random() * Math.PI * 2);
    }
    
    // Offset very slightly along normal to avoid z-fighting
    splatter.position.add(normal.clone().multiplyScalar(0.0001));
    
    this.scene.add(splatter);
    this.paintSplatters.push({
      mesh: splatter,
      createdAt: performance.now()
    });
  }
  
  createOrganicSplatterGeometry(baseRadius) {
    // Create fractal-like splatter shape with chaotic edges
    const points = [];
    const numPoints = 16 + Math.floor(Math.random() * 8); // 16-24 points for complexity
    
    // Generate main splatter body with irregular radius
    for (let i = 0; i < numPoints; i++) {
      const angle = (i / numPoints) * Math.PI * 2;
      
      // Fractal-like radius variation - multiple levels of chaos
      const baseVariation = 0.7 + Math.random() * 0.6; // 0.7-1.3 multiplier
      const mediumVariation = 0.8 + Math.random() * 0.4; // Secondary chaos
      const fineVariation = 0.9 + Math.random() * 0.2; // Fine detail
      
      const radius = baseRadius * baseVariation * mediumVariation * fineVariation;
      
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      
      points.push(new THREE.Vector2(x, y));
    }
    
    // Add random droplet extensions (paint drips/spatters)
    const numDroplets = Math.floor(Math.random() * 4) + 2; // 2-5 droplets
    for (let i = 0; i < numDroplets; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = baseRadius * (1.5 + Math.random() * 1.5); // Extend beyond main body
      const dropletSize = baseRadius * (0.2 + Math.random() * 0.3);
      
      // Create small droplet
      const dropletPoints = 6;
      for (let j = 0; j < dropletPoints; j++) {
        const dropletAngle = (j / dropletPoints) * Math.PI * 2;
        const dropletRadius = dropletSize * (0.8 + Math.random() * 0.4);
        
        const x = Math.cos(angle) * distance + Math.cos(dropletAngle) * dropletRadius;
        const y = Math.sin(angle) * distance + Math.sin(dropletAngle) * dropletRadius;
        
        points.push(new THREE.Vector2(x, y));
      }
    }
    
    // Create shape from points
    const shape = new THREE.Shape(points);
    
    // Create geometry with minimal thickness for flat splatter
    return new THREE.ExtrudeGeometry(shape, {
      depth: 0.001,
      bevelEnabled: false
    });
  }
  
  // Method to clear all paint (if needed)
  clearPaint() {
    this.paintSplatters.forEach(splatter => {
      this.scene.remove(splatter.mesh);
    });
    this.paintSplatters = [];
  }
  
  // Get aiming direction from camera
  getAimDirection() {
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);
    return direction;
  }
}

// Initialize paintball system
const paintballSystem = new PaintballSystem(scene, camera, renderer);

// Function to update all panel backgrounds
function updatePanelBackgrounds() {
  panelCanvases.forEach(panelInfo => {
    const { canvas, ctx, content, index } = panelInfo;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw matrix background (sample from shared canvas)
    if (panelMatrixOpacityValue > 0) {
      const sampleX = (index * 120) % (panelMatrixCanvas.width - canvas.width);
      const sampleY = Math.floor(index / 4) * 250 % (panelMatrixCanvas.height - canvas.height);
      
      ctx.globalAlpha = panelMatrixOpacityValue;
      ctx.drawImage(panelMatrixCanvas, sampleX, sampleY, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
      ctx.globalAlpha = 1;
    }
    
    // Draw background (subtle darkness for readability while showing matrix)
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    ctx.strokeStyle = `rgba(${content.color >> 16 & 255}, ${content.color >> 8 & 255}, ${content.color & 255}, 0.8)`;
    ctx.lineWidth = 3;
    ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
    
    // Draw title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px monospace';
    ctx.fillText(content.title, 20, 40);
    
    // Draw content with word wrap
    ctx.font = '16px monospace';
    const lines = content.content.split('\n');
    const maxWidth = canvas.width - 40;
    let currentY = 80;
    
    lines.forEach((line) => {
      if (line.trim() === '') {
        currentY += 25;
        return;
      }
      
      const words = line.split(' ');
      let currentLine = '';
      
      for (let n = 0; n < words.length; n++) {
        const testLine = currentLine + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        
        if (testWidth > maxWidth && n > 0) {
          ctx.fillText(currentLine, 20, currentY);
          currentLine = words[n] + ' ';
          currentY += 25;
        } else {
          currentLine = testLine;
        }
      }
      ctx.fillText(currentLine, 20, currentY);
      currentY += 25;
    });
    
    panelInfo.texture.needsUpdate = true;
  });
}

// Control stations
const controlStations = [];

function createControlStation(x, z) {
  const group = new THREE.Group();
  
  // Base
  const baseGeometry = new THREE.BoxGeometry(2, 0.5, 1);
  const baseMaterial = new THREE.MeshPhongMaterial({ 
    color: 0x1a1a2e,
    emissive: 0x54c6ff,
    emissiveIntensity: 0.1
  });
  const base = new THREE.Mesh(baseGeometry, baseMaterial);
  group.add(base);
  
  // Screen
  const screenGeometry = new THREE.PlaneGeometry(1.8, 0.8);
  const screenMaterial = new THREE.MeshPhongMaterial({ 
    color: 0x54c6ff,
    emissive: 0x54c6ff,
    emissiveIntensity: 0.5
  });
  const screen = new THREE.Mesh(screenGeometry, screenMaterial);
  screen.position.y = 0.5;
  screen.rotation.x = -Math.PI / 6;
  group.add(screen);
  
  // Animated display canvas
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  
  const texture = new THREE.CanvasTexture(canvas);
  const displayMaterial = new THREE.MeshBasicMaterial({ map: texture });
  const display = new THREE.Mesh(screenGeometry, displayMaterial);
  display.position.copy(screen.position);
  display.position.z += 0.01;
  display.rotation.copy(screen.rotation);
  group.add(display);
  
  group.position.set(x, 0, z);
  scene.add(group);
  
  controlStations.push({ group, canvas, ctx, texture });
}

// Create control stations
createControlStation(-3, 6);
createControlStation(0, 6);
createControlStation(3, 6);

// Particles
const particlesGeometry = new THREE.BufferGeometry();
const particlesCount = 1000;
const posArray = new Float32Array(particlesCount * 3);

for (let i = 0; i < particlesCount * 3; i++) {
  posArray[i] = (Math.random() - 0.5) * 50;
}

particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const particlesMaterial = new THREE.PointsMaterial({
  size: 0.02,
  color: 0x54c6ff,
  transparent: true,
  opacity: 0.6
});
const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

// Panel animation
let currentFocus = -1;
let globalAnimating = false;

function animatePanel(group, toFront) {
  if (group.userData.animating) return;
  group.userData.animating = true;
  globalAnimating = true;
  
  const startPos = group.position.clone();
  const startRot = group.rotation.clone();
  const startScale = group.scale.clone();
  
  // Dynamic z-depth based on aspect ratio
  let dynamicTargetPos;
  if (toFront) {
    const aspectRatio = window.innerWidth / window.innerHeight;
    const isLandscape = aspectRatio > 1;
    const zDepth = isLandscape ? panelZDepthLandscapeValue : panelZDepthPortraitValue;
    dynamicTargetPos = new THREE.Vector3(ORIGINAL_CAMERA_POSITION.x, 2.5, zDepth);
  } else {
    dynamicTargetPos = group.userData.originalPosition;
  }
  
  const targetPos = dynamicTargetPos;
  const targetRot = toFront ? group.userData.targetRotation : group.userData.originalRotation;
  const targetScale = toFront ? group.userData.targetScale : group.userData.originalScale;
  
  // Store camera target for smooth tracking
  const startCameraTarget = ORIGINAL_CAMERA_TARGET.clone();
  
  let progress = 0;
  const animate = () => {
    progress += 0.025;
    if (progress >= 1) {
      group.userData.animating = false;
      group.userData.focused = toFront;
      globalAnimating = false;
      // Restore camera to original target
      camera.lookAt(ORIGINAL_CAMERA_TARGET);
      return;
    }
    
    const eased = 1 - Math.pow(1 - progress, 3);
    
    group.position.lerpVectors(startPos, targetPos, eased);
    group.scale.lerpVectors(startScale, targetScale, eased);
    
    // Slerp rotation for smooth animation
    group.rotation.x = startRot.x + (targetRot.x - startRot.x) * eased;
    group.rotation.y = startRot.y + (targetRot.y - startRot.y) * eased;
    group.rotation.z = startRot.z + (targetRot.z - startRot.z) * eased;
    
    // Add floating effect when focused
    if (toFront) {
      group.position.y = targetPos.y + Math.sin(progress * Math.PI) * 0.3;
    }
    
    // Camera tracks the center of the panel as it moves (only on fly in)
    if (toFront) {
      const currentCameraTarget = new THREE.Vector3();
      currentCameraTarget.lerpVectors(startCameraTarget, group.position, eased);
      camera.lookAt(currentCameraTarget);
    }
    
    requestAnimationFrame(animate);
  };
  animate();
}

function focusScreen(index) {
  // Ignore input while any animation is in progress
  if (globalAnimating) return;
  
  const group = screenGroups[index];
  
  // Special handling for panel 0 - AI Terminal
  if (index === 0) {
    if (currentFocus === 0 && group.userData.focused) {
      // Hide terminal and return panel
      hideAITerminal();
      animatePanel(group, false);
      currentFocus = -1;
    } else {
      // Show terminal and bring panel forward
      if (currentFocus !== -1 && currentFocus !== index) {
        animatePanel(screenGroups[currentFocus], false);
      }
      animatePanel(group, true);
      currentFocus = index;
      showAITerminal();
    }
    return;
  }
  
  // Standard panel handling for non-AI panels
  if (currentFocus === index && group.userData.focused) {
    // Return to original position
    animatePanel(group, false);
    currentFocus = -1;
  } else {
    // Return previous panel if any
    if (currentFocus !== -1 && currentFocus !== index) {
      animatePanel(screenGroups[currentFocus], false);
    }
    // Bring new panel forward
    animatePanel(group, true);
    currentFocus = index;
  }
  
  // Hide AI terminal if switching to any other panel
  hideAITerminal();
}

// Camera movement system
function updateCameraMovement() {
  // Only allow movement when camera is free
  if (!isCameraFree) return;
  
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();
  
  // Get camera direction for forward/back movement
  camera.getWorldDirection(direction);
  
  // Get right vector for strafe movement
  const right = new THREE.Vector3();
  right.crossVectors(camera.up, direction).normalize();
  
  // Apply movement based on pressed keys
  if (keys.w) velocity.add(direction.clone().multiplyScalar(moveSpeedValue));
  if (keys.s) velocity.add(direction.clone().multiplyScalar(-moveSpeedValue));
  if (keys.a) velocity.add(right.clone().multiplyScalar(moveSpeedValue));
  if (keys.d) velocity.add(right.clone().multiplyScalar(-moveSpeedValue));
  
  // Apply movement with boundary checking and bounce
  const newPosition = camera.position.clone().add(velocity);
  
  // Check collision with focused panel
  if (currentFocus !== -1) {
    const focusedPanel = screenGroups[currentFocus];
    if (focusedPanel.userData.focused) {
      const panelPos = focusedPanel.position;
      const distance = newPosition.distanceTo(panelPos);
      
      // If too close to focused panel, bounce back
      if (distance < 3) {
        const direction = newPosition.clone().sub(panelPos).normalize();
        newPosition.copy(panelPos.clone().add(direction.multiplyScalar(3)));
        velocity.multiplyScalar(-0.3); // Bounce effect
      }
    }
  }
  
  // Check X bounds with bounce
  if (newPosition.x < CAMERA_BOUNDS.x.min) {
    newPosition.x = CAMERA_BOUNDS.x.min;
    velocity.x = Math.abs(velocity.x) * 0.3; // Bounce back
  } else if (newPosition.x > CAMERA_BOUNDS.x.max) {
    newPosition.x = CAMERA_BOUNDS.x.max;
    velocity.x = -Math.abs(velocity.x) * 0.3; // Bounce back
  }
  
  // Check Y bounds with bounce
  if (newPosition.y < CAMERA_BOUNDS.y.min) {
    newPosition.y = CAMERA_BOUNDS.y.min;
    velocity.y = Math.abs(velocity.y) * 0.3; // Bounce back
  } else if (newPosition.y > CAMERA_BOUNDS.y.max) {
    newPosition.y = CAMERA_BOUNDS.y.max;
    velocity.y = -Math.abs(velocity.y) * 0.3; // Bounce back
  }
  
  // Check Z bounds with bounce
  if (newPosition.z < CAMERA_BOUNDS.z.min) {
    newPosition.z = CAMERA_BOUNDS.z.min;
    velocity.z = Math.abs(velocity.z) * 0.3; // Bounce back
  } else if (newPosition.z > CAMERA_BOUNDS.z.max) {
    newPosition.z = CAMERA_BOUNDS.z.max;
    velocity.z = -Math.abs(velocity.z) * 0.3; // Bounce back
  }
  
  camera.position.copy(newPosition);
}

// Mouse movement for camera look
function onMouseMove(event) {
  if (!isPointerLocked || !isCameraFree || isTouchDevice) return;
  
  const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
  const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
  
  mouseX += movementX * mouseSensitivityValue * 0.002;
  mouseY += movementY * mouseSensitivityValue * 0.002;
  
  // Limit vertical rotation
  mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
  
  // Apply rotation
  camera.rotation.order = 'YXZ';
  camera.rotation.y = -mouseX;
  camera.rotation.x = -mouseY;
}

// Touch event handlers for mobile camera control
function onTouchStart(event) {
  if (!isCameraFree || !isTouchDevice) return;
  event.preventDefault();
  
  const touch = event.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}

function onTouchMove(event) {
  if (!isCameraFree || !isTouchDevice) return;
  event.preventDefault();
  
  const touch = event.touches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  
  // Apply touch sensitivity (inverted for mobile)
  mouseX -= deltaX * mouseSensitivityValue * 0.003;
  mouseY -= deltaY * mouseSensitivityValue * 0.003;
  
  // Limit vertical rotation
  mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
  
  // Apply rotation
  camera.rotation.order = 'YXZ';
  camera.rotation.y = -mouseX;
  camera.rotation.x = -mouseY;
  
  // Update touch start position for continuous rotation
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}

function onTouchEnd(event) {
  if (!isCameraFree || !isTouchDevice) return;
  event.preventDefault();
}

// Pointer lock handlers
function onPointerLockChange() {
  isPointerLocked = document.pointerLockElement === renderer.domElement;
}

function onPointerLockError() {
  console.log('Pointer lock error');
}

// Initialize pointer lock (without auto-start)
function initPointerLock() {
  document.addEventListener('pointerlockchange', onPointerLockChange);
  document.addEventListener('pointerlockerror', onPointerLockError);
  document.addEventListener('mousemove', onMouseMove);
  
  // Add touch event listeners for mobile support
  renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
  renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
  renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
}

// Camera toggle functionality
function toggleCamera() {
  const cameraButton = document.getElementById('camera-toggle');
  const fireButton = document.getElementById('fire-button');
  const instructions = document.getElementById('instructions');
  
  if (isCameraFree) {
    // Lock camera and return to original position
    isCameraFree = false;
    cameraButton.classList.remove('active');
    instructions.textContent = 'panel';
    
    // Hide fire button
    if (isTouchDevice) {
      fireButton.style.display = 'none';
    }
    
    // Exit pointer lock (desktop only)
    if (!isTouchDevice && document.exitPointerLock) {
      document.exitPointerLock();
    }
    
    // Smoothly return camera to original position
    returnCameraToOriginal();
  } else {
    // Free camera
    isCameraFree = true;
    cameraButton.classList.add('active');
    instructions.textContent = isTouchDevice ? 
      'aim & use fire button to shoot!' : 
      'click to shoot paintballs! ‚Ä¢ P to clear paint';
    
    // Show fire button on touch devices
    if (isTouchDevice) {
      fireButton.style.display = 'flex';
    }
    
    // Request pointer lock (desktop only)
    if (!isTouchDevice) {
      renderer.domElement.requestPointerLock();
    }
  }
}

// Smooth camera return to original position
function returnCameraToOriginal() {
  const startPos = camera.position.clone();
  const startRotX = camera.rotation.x;
  const startRotY = camera.rotation.y;
  
  let progress = 0;
  const animate = () => {
    progress += 0.03;
    if (progress >= 1) {
      camera.position.copy(ORIGINAL_CAMERA_POSITION);
      camera.lookAt(ORIGINAL_CAMERA_TARGET);
      mouseX = 0;
      mouseY = 0;
      return;
    }
    
    const eased = 1 - Math.pow(1 - progress, 3);
    
    // Smoothly interpolate position
    camera.position.lerpVectors(startPos, ORIGINAL_CAMERA_POSITION, eased);
    
    // Smoothly interpolate rotation back to looking at target
    const targetRotation = new THREE.Euler();
    const tempCamera = new THREE.PerspectiveCamera();
    tempCamera.position.copy(camera.position);
    tempCamera.lookAt(ORIGINAL_CAMERA_TARGET);
    targetRotation.copy(tempCamera.rotation);
    
    camera.rotation.x = startRotX + (targetRotation.x - startRotX) * eased;
    camera.rotation.y = startRotY + (targetRotation.y - startRotY) * eased;
    
    requestAnimationFrame(animate);
  };
  animate();
}

// Panel cycling state
let panelCycleState = 0; // 0-6 for panels 1-7, 7 for home state

// Panel cycling button
document.getElementById('instructions').addEventListener('click', () => {
  // Ignore input while any animation is in progress
  if (globalAnimating) return;
  
  if (panelCycleState >= 0 && panelCycleState <= 6) {
    // Focus on panel (1-7)
    focusScreen(panelCycleState);
  } else {
    // Home state - return all panels
    if (currentFocus !== -1) {
      animatePanel(screenGroups[currentFocus], false);
      currentFocus = -1;
    }
  }
  
  // Increment cycle state with wrap-around
  panelCycleState = (panelCycleState + 1) % 8; // 0-7, then back to 0
});

// Camera toggle button
document.getElementById('camera-toggle').addEventListener('click', () => {
  toggleCamera();
});

// Settings toggle button
document.getElementById('settings-toggle').addEventListener('click', () => {
  const controls = document.getElementById('controls');
  const settingsButton = document.getElementById('settings-toggle');
  
  if (controls.style.display === 'none' || controls.style.display === '') {
    controls.style.display = 'block';
    settingsButton.classList.add('active');
  } else {
    controls.style.display = 'none';
    settingsButton.classList.remove('active');
  }
});

// Helper function to check if AI terminal input is focused
function isAITerminalInputFocused() {
  const activeElement = document.activeElement;
  return activeElement === aiModelInput || activeElement === aiInput;
}

// WASD movement controls
window.addEventListener('keydown', (e) => {
  const key = e.key.toLowerCase();
  
  // Skip all shortcuts if AI terminal input is focused (except ESC to close terminal)
  if (isAITerminalInputFocused()) {
    if (key === 'escape') {
      // Allow ESC to close AI terminal
      hideAITerminal();
      if (currentFocus === 0) {
        animatePanel(screenGroups[0], false);
        currentFocus = -1;
      }
    }
    return;
  }
  
  // WASD movement
  if (key === 'w') keys.w = true;
  if (key === 'a') keys.a = true;
  if (key === 's') keys.s = true;
  if (key === 'd') keys.d = true;
  
  // Panel controls
  const numKey = parseInt(e.key);
  if (numKey >= 1 && numKey <= 7) {
    // Ignore input while any animation is in progress
    if (globalAnimating) return;
    focusScreen(numKey - 1);
    // Sync button state with keyboard
    panelCycleState = numKey; // Next click will advance from current panel
  } else if (numKey === 0) {
    // Ignore input while any animation is in progress
    if (globalAnimating) return;
    if (currentFocus !== -1) {
      animatePanel(screenGroups[currentFocus], false);
      currentFocus = -1;
    }
    // Sync button state
    panelCycleState = 0; // Next click will go to panel 1
  } else if (key === 'c') {
    // Toggle controls visibility
    const controls = document.getElementById('controls');
    if (controls.style.display === 'none' || controls.style.display === '') {
      controls.style.display = 'block';
    } else {
      controls.style.display = 'none';
    }
  } else if (key === 'escape') {
    // Lock camera if it's currently free
    if (isCameraFree) {
      toggleCamera();
    }
  } else if (key === 'p') {
    // Clear all paint
    paintballSystem.clearPaint();
  }
});

window.addEventListener('keyup', (e) => {
  const key = e.key.toLowerCase();
  
  // Skip WASD if AI terminal input is focused
  if (isAITerminalInputFocused()) {
    return;
  }
  
  // WASD movement
  if (key === 'w') keys.w = false;
  if (key === 'a') keys.a = false;
  if (key === 's') keys.s = false;
  if (key === 'd') keys.d = false;
});

// =============================================================================
// PAINTBALL INPUT HANDLING
// =============================================================================

// Mouse click to launch paintballs
renderer.domElement.addEventListener('click', (event) => {
  // Only allow paintball shooting when camera is free
  if (!isCameraFree) return;
  
  // Prevent shooting during pointer lock request
  if (!isTouchDevice && !isPointerLocked) return;
  
  // Get camera position and direction
  const startPosition = camera.position.clone();
  const aimDirection = paintballSystem.getAimDirection();
  
  // Add slight random spread for realism
  const spread = 0.02;
  aimDirection.x += (Math.random() - 0.5) * spread;
  aimDirection.y += (Math.random() - 0.5) * spread;
  aimDirection.z += (Math.random() - 0.5) * spread;
  aimDirection.normalize();
  
  // Launch paintball with power based on mouse position (simple aim adjustment)
  const power = 15 + Math.random() * 5; // 15-20 power range
  paintballSystem.launch(startPosition, aimDirection, power);
  
  // Prevent event bubbling
  event.preventDefault();
  event.stopPropagation();
});

// Fire button for mobile paintball launching
document.getElementById('fire-button').addEventListener('touchend', (event) => {
  // Only allow paintball shooting when camera is free
  if (!isCameraFree || !isTouchDevice) return;
  
  // Get camera position and direction
  const startPosition = camera.position.clone();
  const aimDirection = paintballSystem.getAimDirection();
  
  // Add slight random spread for realism
  const spread = 0.02;
  aimDirection.x += (Math.random() - 0.5) * spread;
  aimDirection.y += (Math.random() - 0.5) * spread;
  aimDirection.z += (Math.random() - 0.5) * spread;
  aimDirection.normalize();
  
  // Launch paintball
  const power = 15 + Math.random() * 5;
  paintballSystem.launch(startPosition, aimDirection, power);
  
  // Visual feedback
  const fireButton = document.getElementById('fire-button');
  fireButton.classList.add('active');
  setTimeout(() => fireButton.classList.remove('active'), 100);
  
  event.preventDefault();
  event.stopPropagation();
});

// Animation loop
let time = 0;

// Matrix effect data for each station
const matrixColumns = [];
const matrixChars = '„Ç¢„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É©„ÉØ„Ç¨„Ç∂„ÉÄ„Éê„Éë„Ç≠„Ç∑„ÉÅ„Éã„Éí„Éü„É™„ÇÆ„Ç∏„ÉÇ„Éì„Éî„ÇØ„Çπ„ÉÑ„Éå„Éï„É†„É´„Ç∞„Ç∫„ÉÖ„Éñ„Éó„Ç±„Çª„ÉÜ„Éç„Éò„É°„É¨„Ç≤„Çº„Éá„Éô„Éö„Ç≥„ÇΩ„Éà„Éé„Éõ„É¢„É≠„Ç¥„Çæ„Éâ„Éú„Éù„ÅÇ„Åã„Åï„Åü„Å™„ÅØ„Åæ„ÇÑ„Çâ„Çè„Åå„Åñ„Å†„Å∞„Å±„Åç„Åó„Å°„Å´„Å≤„Åø„Çä„Åé„Åò„Å¢„Å≥„Å¥„Åè„Åô„Å§„Å¨„Åµ„ÇÄ„Çã„Åê„Åö„Å•„Å∂„Å∑„Åë„Åõ„Å¶„Å≠„Å∏„ÇÅ„Çå„Åí„Åú„Åß„Åπ„Å∫„Åì„Åù„Å®„ÅÆ„Åª„ÇÇ„Çç„Åî„Åû„Å©„Åº„ÅΩ‰∏≠ÂõΩÊó•Êú¨Ë™ûÊñáÂ≠ó‰π¶ÂÜôÊ±âÂ≠óÌïúÍµ≠Ïñ¥Í∏ÄÏûêÏ°∞ÏÑ†ÎßêÎ¨∏Ïûê';
const stationColors = ['#ff0040', '#00ff40', '#0040ff']; // Red, Green, Blue

// Initialize matrix columns for each station
function initializeMatrix() {
  for (let stationIndex = 0; stationIndex < 3; stationIndex++) {
    const columns = [];
    const columnCount = 20; // Number of falling columns
    
    for (let i = 0; i < columnCount; i++) {
      columns.push({
        x: (i * 12) + Math.random() * 4, // Column position with slight randomness
        y: Math.random() * -500, // Start above screen
        speed: 1 + Math.random() * 1.5, // Fall speed (half of original)
        chars: [], // Characters in this column
        lastChar: 0 // Time since last character
      });
    }
    matrixColumns.push(columns);
  }
}

function updateControlStations() {
  controlStations.forEach((station, i) => {
    const { ctx, canvas, texture } = station;
    
    // Darken background for trail effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Matrix falling code effect
    const columns = matrixColumns[i];
    const color = stationColors[i];
    
    columns.forEach(column => {
      // Move column down
      column.y += column.speed;
      
      // Add new character occasionally
      column.lastChar += 1;
      if (column.lastChar > 8 + Math.random() * 8) {
        column.chars.push({
          char: matrixChars[Math.floor(Math.random() * matrixChars.length)],
          y: column.y,
          alpha: 1
        });
        column.lastChar = 0;
      }
      
      // Update and draw characters
      for (let j = column.chars.length - 1; j >= 0; j--) {
        const char = column.chars[j];
        
        // Character fades as it gets older
        const distanceFromHead = column.y - char.y;
        char.alpha = Math.max(0, 1 - (distanceFromHead / 100));
        
        if (char.alpha > 0) {
          // Bright head character
          if (j === column.chars.length - 1) {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px monospace';
          } else {
            // Trailing characters in station color
            ctx.fillStyle = color.replace(')', `, ${char.alpha})`).replace('#', 'rgba(').replace(/(.{2})(.{2})(.{2})/, '$1, $2, $3');
            if (!ctx.fillStyle.includes('rgba')) {
              // Fallback for hex colors
              const r = parseInt(color.slice(1, 3), 16);
              const g = parseInt(color.slice(3, 5), 16);
              const b = parseInt(color.slice(5, 7), 16);
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${char.alpha})`;
            }
            ctx.font = '12px monospace';
          }
          
          ctx.fillText(char.char, column.x, char.y);
        } else {
          // Remove faded characters
          column.chars.splice(j, 1);
        }
      }
      
      // Reset column when it goes off screen
      if (column.y > canvas.height + 50) {
        column.y = Math.random() * -200;
        column.chars = [];
      }
    });
    
    texture.needsUpdate = true;
  });
}

function animate() {
  requestAnimationFrame(animate);
  time += 0.01;
  
  // Update camera movement
  updateCameraMovement();
  
  // Update paintball system
  paintballSystem.update(0.016); // ~60fps delta time
  
  // Animate lights - each moves randomly in its assigned constrained box
  lights.forEach((light, i) => {
    const layer = light.userData.layer;
    const lightIndex = light.userData.lightIndex;
    const baseZ = light.userData.baseZ;
    
    // Smooth random movement within small constrained box
    light.position.x = Math.sin(time * 0.7 + i * 2) * 10;                    // x = ¬±10 (smaller than glass)
    light.position.y = 5 + Math.sin(time * 0.9 + i * 1.3) * 2;              // y = 3-7 (constrained height)
    light.position.z = baseZ + Math.sin(time * 0.5 + i * 1.7) * 1;          // z varies ¬±1 in layer
    
    // INTENSE color cycling for dramatic glass effects
    const hue = (time * 100 + layer * 90 + lightIndex * 30) % 360; // Faster, bolder color changes
    light.color.setHSL(hue / 360, 1.0, 0.8); // Maximum saturation and high brightness
    
    // Dynamic intensity based on user controls
    light.intensity = spotlightIntensityValue + Math.sin(time * 6 + i * 3) * (spotlightIntensityValue * 0.8);
  });
  
  // Update radar system
  updateRadar();
  
  // Update radar plane opacity
  radarMaterial.opacity = radarOpacityValue;
  
  // Update panel matrix system
  updatePanelMatrix();
  updatePanelBackgrounds();
  
  // Static glass panels - DRAMATIC material property changes for MAXIMUM intensity
  glassPanels.forEach((panel, i) => {
    // DRAMATIC opacity pulsing to enhance light interaction
    panel.material.opacity = 0.35 + Math.sin(time * 3 + i * 1.5) * 0.25; // 0.1 to 0.6 range
    
    // EXTREME IOR shifts for dramatic light refraction
    panel.material.ior = (2.0 + i * 0.3) + Math.sin(time * 2 + i) * 0.8; // 1.2 to 3.5 range
  });
  
  // Background color effects handled by glass panels and sphere
  
  // Animate background glow sphere color and opacity
  const bgHue = (time * 15) % 120; // Slower cycle, 120 degree range
  const bgColor = new THREE.Color().setHSL((bgHue + 240) / 360, 0.8, sphereIntensityValue); // Purple to blue
  backgroundSphere.material.color = bgColor;
  backgroundSphere.material.opacity = sphereOpacityValue;
  
  // Animate fog color
  const fogHue = (time * 10) % 60; // Even slower, smaller range
  const fogColor = new THREE.Color().setHSL((fogHue + 260) / 360, fogSaturationValue, fogOpacityValue); // Dark purple to dark blue
  scene.fog.color = fogColor;
  
  // Animate particles
  particlesMesh.rotation.y += 0.0005;
  
  // Pulse screens
  screens.forEach((screen, i) => {
    screen.material.emissiveIntensity = 0.2 + Math.sin(time * 2 + i) * 0.1;
  });
  
  // Float unfocused panels slightly and update opacities
  screenGroups.forEach((group, i) => {
    if (!group.userData.focused && !group.userData.animating) {
      group.position.y = group.userData.originalPosition.y + Math.sin(time + i) * 0.1;
    }
    
    // Update panel opacities from controls
    if (group.userData.screenMaterial) {
      group.userData.screenMaterial.opacity = panelBgOpacityValue;
    }
    if (group.userData.textMaterial) {
      group.userData.textMaterial.opacity = panelTextOpacityValue;
    }
  });
  
  // Update control stations
  updateControlStations();
  
  renderer.render(scene, camera);
}

// Initialize controls
setupControls();

// Initialize pointer lock event listeners
initPointerLock();

// Initialize matrix effect
initializeMatrix();

// Initialize panel matrix
initializePanelMatrix();

animate();

// Handle resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// =============================================================================
// AI TERMINAL CHAT SYSTEM
// =============================================================================

// AI System State
let aiEngine = null;
let isAIReady = false;
let isAILoading = false;
let chatHistory = [];
let isTyping = false;
let selectedModel = null;
let isModelSelected = false;

// Dual library model definitions
const MLC_MODELS = {
  1: {
    name: 'TinyLlama-1.1B-Chat',
    id: 'TinyLlama-1.1B-Chat-v1.0-q4f16_1-MLC',
    size: '700MB',
    description: 'Ultra Fast, WebGPU',
    type: 'mlc'
  },
  2: {
    name: 'Qwen2-0.5B-Instruct', 
    id: 'Qwen2-0.5B-Instruct-q4f16_1-MLC',
    size: '950MB',
    description: 'Fast, Balanced',
    type: 'mlc'
  },
  3: {
    name: 'Qwen2-1.5B-Instruct',
    id: 'Qwen2-1.5B-Instruct-q4f16_1-MLC', 
    size: '1.6GB',
    description: 'High Quality',
    type: 'mlc'
  }
};

const TRANSFORMERS_MODELS = {
  1: {
    name: 'SmolLM-360M-Instruct',
    id: 'HuggingFaceTB/SmolLM-360M-Instruct',
    size: '200MB',
    description: 'Ultra Fast, Mobile Optimized',
    type: 'transformers'
  },
  2: {
    name: 'Qwen2-0.5B-Instruct',
    id: 'Xenova/Qwen2-0.5B-Instruct',
    size: '400MB', 
    description: 'Fast, Mobile-friendly',
    type: 'transformers'
  },
  3: {
    name: 'Phi-3.5-mini-instruct',
    id: 'microsoft/Phi-3.5-mini-instruct',
    size: '2.2GB',
    description: 'Advanced (Desktop Only)',
    type: 'transformers'
  }
};

// AI_MODELS will be set dynamically after browser detection

// Terminal elements
const aiTerminal = document.getElementById('ai-terminal');
const aiChatContainer = document.getElementById('ai-chat-container');
const aiInputContainer = document.getElementById('ai-input-container');
const aiInput = document.getElementById('ai-input');
const aiModelInputContainer = document.getElementById('ai-model-input-container');
const aiModelInput = document.getElementById('ai-model-input');
const aiTerminalClose = document.getElementById('ai-terminal-close');

// Setup terminal interface based on browser
function setupTerminalInterface() {
  console.log('setupTerminalInterface called');
  console.log('Browser info:', window.browserInfo);
  
  const isSafari = window.browserInfo?.needsFallback || false;
  const modelOptionsDiv = document.getElementById('model-options');
  
  console.log('Model options div found:', modelOptionsDiv);
  
  if (!modelOptionsDiv) {
    console.error('Could not find model-options div!');
    return;
  }
  
  if (isSafari) {
    console.log('Setting up Safari interface');
    // Safari: Auto-select SmolLM, simple interface
    modelOptionsDiv.innerHTML = `
      <div style="color: #54c6ff; margin-bottom: 15px;">SmolLM-360M-Instruct (200MB, Ultra Fast, Mobile Optimized)</div>
      <div style="color: #888; font-size: 11px;">Optimized for mobile browsers and Safari</div>
      <div style="color: #ff8800; font-size: 10px; margin-top: 10px; font-style: italic;">(More powerful models and much faster performance on desktop Chrome with WebGPU support)</div>
    `;
    
    // Update system message
    const systemDiv = document.querySelector('#model-selector div[style*="ff8800"]');
    if (systemDiv) systemDiv.textContent = '[SYSTEM Safari/iOS] MissionFocused.ai AI Ready:';
    
    // Update instruction
    const instructionDiv = document.querySelector('#model-selector div:nth-child(4)');
    if (instructionDiv) instructionDiv.textContent = 'Press any key to download and run model:';
    
    // Auto-select the SmolLM model
    selectedModel = TRANSFORMERS_MODELS[1];
    aiModelInput.placeholder = "press enter";
    
  } else {
    console.log('Setting up WebGPU interface');
    // Compatible browsers: Show model selection
    let optionsHtml = '';
    for (let i = 1; i <= 3; i++) {
      const model = MLC_MODELS[i];
      optionsHtml += `<div style="color: #54c6ff;">${i}. ${model.name} <span style="color: #888; font-size: 11px;">(${model.size}, ${model.description})</span></div>`;
    }
    modelOptionsDiv.innerHTML = optionsHtml;
    
    // Update system message
    const systemDiv = document.querySelector('#model-selector div[style*="ff8800"]');
    if (systemDiv) systemDiv.textContent = '[SYSTEM WebGPU] Select AI consciousness substrate:';
    
    aiModelInput.placeholder = "1";
  }
  
  console.log('Setup complete, model options HTML:', modelOptionsDiv.innerHTML);
}

// Show AI Terminal
function showAITerminal() {
  aiTerminal.classList.add('active');
  
  // Force setup every time to ensure it works
  setupTerminalInterface();
  
  if (!isModelSelected) {
    // Focus on model selection input
    aiModelInput.focus();
  } else if (isAIReady) {
    // Already loaded, focus on chat input
    aiInput.focus();
  }
}

// Hide AI Terminal
function hideAITerminal() {
  aiTerminal.classList.remove('active');
}

// Terminal close button
aiTerminalClose.addEventListener('click', () => {
  hideAITerminal();
  if (currentFocus === 0) {
    animatePanel(screenGroups[0], false);
    currentFocus = -1;
  }
});

// Model selection input handler
aiModelInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const isSafari = window.browserInfo?.needsFallback || false;
    
    if (isSafari) {
      // Safari: Any key press loads the pre-selected TinyLlama
      if (selectedModel) {
        isModelSelected = true;
        aiModelInput.value = '';
        loadAIModel(selectedModel);
      }
    } else {
      // Compatible browsers: Number selection
      const selection = parseInt(aiModelInput.value.trim());
      if (selection >= 1 && selection <= 3) {
        selectedModel = MLC_MODELS[selection];
        isModelSelected = true;
        aiModelInput.value = '';
        loadAIModel(selectedModel);
      } else {
        // Invalid selection - flash red briefly
        aiModelInput.style.color = '#ff4444';
        setTimeout(() => {
          aiModelInput.style.color = '#54c6ff';
        }, 300);
      }
    }
  }
});

// Check WebGPU Support
async function checkWebGPUSupport() {
  if (!navigator.gpu) {
    showAIError("WebGPU not supported. Please use Chrome/Edge with WebGPU enabled.");
    return false;
  }
  
  try {
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      showAIError("WebGPU adapter not found. Please ensure you have a compatible GPU.");
      return false;
    }
    return true;
  } catch (error) {
    showAIError(`WebGPU initialization failed: ${error.message}`);
    return false;
  }
}

// Real-time Loading Animation with Progress
function showLoadingAnimation(modelInfo) {
  // Hide model selector and show loading screen
  aiChatContainer.innerHTML = `
    <div class="scan-lines"></div>
    <div style="color: #00ff41; font-weight: bold; margin-bottom: 20px;">MissionFocused.ai Neural Interface v2.1.7</div>
    <div style="color: #ff8800; margin-bottom: 15px;">[SYSTEM] Initializing ${modelInfo.name}</div>
    <div style="color: #888; font-size: 11px; margin-bottom: 20px;">Size: ${modelInfo.size} - ${modelInfo.description}</div>
    <div id="loading-frame" style="color: #54c6ff; font-size: 14px; margin-bottom: 15px;">‚†ã Preparing neural pathways...</div>
    <div style="margin-bottom: 10px;">
      <div style="background: rgba(0,255,65,0.2); height: 8px; border-radius: 4px; overflow: hidden;">
        <div id="progress-bar" style="background: #00ff41; height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 4px;"></div>
      </div>
    </div>
    <div id="progress-text" style="color: #888; font-size: 11px; text-align: center;">
      Downloading consciousness substrate...
    </div>
  `;
  
  aiModelInputContainer.style.display = 'none';
}

// Update loading progress
function updateLoadingProgress(progress, text) {
  const progressBar = document.getElementById('progress-bar');
  const progressText = document.getElementById('progress-text');
  const loadingFrame = document.getElementById('loading-frame');
  
  if (progressBar) {
    progressBar.style.width = `${Math.min(100, Math.max(0, progress * 100))}%`;
  }
  
  if (progressText) {
    progressText.textContent = text || `Downloading... ${Math.round(progress * 100)}%`;
  }
  
  // Spinner animation
  if (loadingFrame) {
    const frames = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'];
    const frameIndex = Math.floor(Date.now() / 150) % frames.length;
    loadingFrame.textContent = `${frames[frameIndex]} Loading neural pathways...`;
  }
}

// Load AI Model with MLC WebLLM (Desktop)
async function loadMLCModel(modelInfo) {
  // Check WebGPU support first
  const webgpuSupported = await checkWebGPUSupport();
  if (!webgpuSupported) return false;
  
  try {
    // Progress callback for real-time updates
    const initProgressCallback = (report) => {
      const progress = report.progress || 0;
      let text = report.text || 'Initializing neural pathways...';
      
      if (report.progress !== undefined) {
        text = `Loading ${modelInfo.name}... ${Math.round(progress * 100)}%`;
      }
      
      updateLoadingProgress(progress, text);
    };

    // Create MLC Engine with progress tracking
    aiEngine = await window.webllm.CreateMLCEngine(modelInfo.id, {
      initProgressCallback: initProgressCallback
    });
    
    return true;
  } catch (error) {
    console.error('MLC Model loading failed:', error);
    throw error;
  }
}

// Load AI Model with Transformers.js (Safari/iOS)
async function loadTransformersModel(modelInfo) {
  try {
    updateLoadingProgress(0.1, `Initializing ${modelInfo.name}...`);
    
    // Load the model with transformers.js using SmolLM configuration
    const { pipeline } = window.transformers;
    
    updateLoadingProgress(0.3, `Downloading ${modelInfo.name}...`);
    
    // Use SmolLM optimized configuration
    aiEngine = await pipeline('text-generation', modelInfo.id, {
      quantized: false,
      device: 'wasm',
      progress_callback: (progress) => {
        const percent = Math.round((progress.progress || 0) * 100);
        updateLoadingProgress(progress.progress || 0, `Loading ${modelInfo.name}... ${percent}%`);
      }
    });
    
    updateLoadingProgress(1.0, 'Model ready!');
    return true;
  } catch (error) {
    console.error('Transformers Model loading failed:', error);
    throw error;
  }
}

// Main AI Model Loading Function
async function loadAIModel(modelInfo) {
  if (isAILoading || isAIReady) return;
  
  isAILoading = true;
  showLoadingAnimation(modelInfo);
  
  try {
    let success = false;
    
    if (modelInfo.type === 'mlc') {
      success = await loadMLCModel(modelInfo);
    } else {
      success = await loadTransformersModel(modelInfo);
    }
    
    if (success) {
      isAIReady = true;
      isAILoading = false;
      
      // Replace loading screen with welcome message
      aiChatContainer.innerHTML = '<div class="scan-lines"></div>';
      addSystemMessage('NEURAL LINK ESTABLISHED', false);
      addSystemMessage(`${modelInfo.name} consciousness online`, false);
      addAIMessage('Greetings! I help nonprofits learn about MissionFocused.ai\'s back office automation platform that lets organizations spend more donations on their actual mission instead of overhead.');
      
      // Show chat input
      aiInputContainer.style.display = 'flex';
      aiInput.focus();
    }
    
  } catch (error) {
    console.error('AI Model loading failed:', error);
    isAILoading = false;
    showAIError(`Failed to load ${modelInfo.name}: ${error.message}`);
  }
}

// Show cyberpunk error message
function showAIError(customMessage = null) {
  const defaultMessage = `
    <div style="font-size: 16px; margin-bottom: 10px;">‚ö†Ô∏è NEURAL LINK FAILED ‚ö†Ô∏è</div>
    <div>INSUFFICIENT QUANTUM PROCESSING CORES</div>
    <div style="margin-top: 10px; font-size: 11px;">
      Error Code: 0x2F4A - WebGPU required for consciousness substrate<br>
      Recommendation: Upgrade to quantum-enabled hardware
    </div>
  `;
  
  const errorContent = customMessage ? 
    `<div style="font-size: 16px; margin-bottom: 10px;">‚ö†Ô∏è NEURAL LINK FAILED ‚ö†Ô∏è</div>
     <div>${customMessage}</div>` : 
    defaultMessage;
    
  aiChatContainer.innerHTML = `
    <div class="scan-lines"></div>
    <div class="chat-error glitch-text">
      ${errorContent}
    </div>
  `;
  
  // Show model selector again
  aiModelInputContainer.style.display = 'flex';
  isModelSelected = false;
}

// Add system message
function addSystemMessage(text, isLoading = false) {
  const messageDiv = document.createElement('div');
  messageDiv.className = 'chat-message chat-system';
  if (isLoading) {
    messageDiv.innerHTML = `<span class="loading-animation">${text}</span>`;
  } else {
    messageDiv.textContent = `[SYSTEM] ${text}`;
  }
  aiChatContainer.appendChild(messageDiv);
  scrollToBottom();
}

// Add user message
function addUserMessage(text) {
  const messageDiv = document.createElement('div');
  messageDiv.className = 'chat-message';
  messageDiv.innerHTML = `<span class="chat-prompt">mf.ai:~$</span> <span class="chat-user">${text}</span>`;
  aiChatContainer.appendChild(messageDiv);
  scrollToBottom();
}

// Add AI message with typing effect
function addAIMessage(text) {
  const messageDiv = document.createElement('div');
  messageDiv.className = 'chat-message chat-ai';
  aiChatContainer.appendChild(messageDiv);
  
  let i = 0;
  isTyping = true;
  
  function typeWriter() {
    if (i < text.length) {
      messageDiv.textContent += text.charAt(i);
      i++;
      scrollToBottom();
      setTimeout(typeWriter, 15 + Math.random() * 25); // Variable typing speed
    } else {
      isTyping = false;
    }
  }
  
  typeWriter();
}

// Scroll chat to bottom
function scrollToBottom() {
  aiChatContainer.scrollTop = aiChatContainer.scrollHeight;
}

// Handle user input
aiInput.addEventListener('keypress', async (e) => {
  if (e.key === 'Enter' && !isTyping && isAIReady && isModelSelected) {
    const userInput = aiInput.value.trim();
    if (!userInput) return;
    
    addUserMessage(userInput);
    aiInput.value = '';
    
    // Generate streaming AI response (handles its own message creation)
    await generateAIResponse(userInput);
  }
});

// Generate AI response (handles both MLC streaming and transformers.js)
async function generateAIResponse(userInput) {
  if (!aiEngine || !isAIReady) {
    addAIMessage("AI core not initialized. Please reload the neural interface.");
    return;
  }
  
  const systemPrompt = "You are an AI assistant for MissionFocused.ai, a non-profit organization that enables back office automation for other nonprofits so they can spend more donations on being mission focused. Our platform streamlines nonprofit back offices with no-code workflows, AI document copilots, composable data hubs, and audit-ready ledgers. We help organizations slash overhead through finance AI agents, CRM migrations, grant compliance automation, and custom AI assistants for case management. Founded by charity veterans who understand limited staff and outdated software constraints, we offer multi-currency/GDPR compliance, on-prem deployment via Kubernetes, and lifetime 30% discounts for early adopters. Contact: hello@missionfocused.ai. Always respond with exactly one sentence and stay focused on our mission of helping nonprofits automate overhead to amplify their impact.";
  
  try {
    if (selectedModel.type === 'mlc') {
      // MLC WebLLM - Streaming response
      const messages = [
        { role: "system", content: systemPrompt },
        { role: "user", content: userInput }
      ];

      const chunks = await aiEngine.chat.completions.create({
        messages: messages,
        stream: true,
        max_tokens: 256,
        temperature: 0.7
      });

      // Create message container for streaming
      const messageDiv = document.createElement('div');
      messageDiv.className = 'chat-message chat-ai';
      aiChatContainer.appendChild(messageDiv);
      
      let fullResponse = '';
      isTyping = true;
      
      // Stream the response in real-time
      for await (const chunk of chunks) {
        const delta = chunk.choices[0]?.delta?.content;
        if (delta) {
          fullResponse += delta;
          messageDiv.textContent = fullResponse;
          scrollToBottom();
        }
      }
      
      isTyping = false;
      
    } else {
      // Transformers.js - SmolLM format with single response and typewriter effect
      const prompt = `<|im_start|>user\n${userInput}<|im_end|>\n<|im_start|>assistant\n`;
      
      const result = await aiEngine(prompt, {
        max_new_tokens: 100,
        do_sample: true,
        temperature: 0.7,
        top_p: 0.9,
        repetition_penalty: 1.1,
        return_full_text: false
      });
      
      let response = result[0].generated_text || '';
      
      // Clean up SmolLM response
      response = response.trim();
      response = response.replace(/<\|im_end\|>.*$/g, '').trim();
      
      // Apply our mission focus to the response
      if (!response || response.length < 3) {
        response = "MissionFocused.ai helps nonprofits automate back office tasks so they can focus more resources on their mission.";
      } else {
        // Ensure the response stays mission-focused
        if (!response.toLowerCase().includes('nonprofit') && !response.toLowerCase().includes('mission')) {
          response = response + " - this relates to how MissionFocused.ai helps nonprofits streamline operations.";
        }
      }
      
      // Add with typewriter effect
      addAIMessage(response);
    }
    
  } catch (error) {
    console.error('AI generation error:', error);
    addAIMessage('Neural pathway temporarily disrupted. Please try again.');
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing AI system');
  console.log('Browser detection result:', window.browserInfo);
  
  // Ensure browser info is available
  if (!window.browserInfo) {
    console.error('Browser info not available, setting fallback');
    window.browserInfo = { 
      isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
      isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
      needsFallback: false 
    };
    window.browserInfo.needsFallback = window.browserInfo.isSafari || window.browserInfo.isIOS;
  }
});
</script>
</body>
</html>
